import { Arn, Lazy, Stack } from 'aws-cdk-lib';
import { Effect, PolicyStatement } from 'aws-cdk-lib/aws-iam';
/**
 * Translates function environment props into appropriate environment records and builds a policy statement
 * in order to resolve secrets in environment props.
 */
export class FunctionEnvironmentTranslator {
    lambda;
    functionEnvironmentProp;
    backendSecretResolver;
    functionEnvironmentTypeGenerator;
    ssmPaths = [];
    ssmEnvVars = {};
    amplifySsmEnvConfigKey = 'AMPLIFY_SSM_ENV_CONFIG';
    ssmValuePlaceholderText = '<value will be resolved during runtime>';
    // List of environment variable names for typed shim generation
    amplifyBackendEnvVarNames = [];
    /**
     * Initialize translated environment variable records
     */
    constructor(lambda, // we need to use a specific type here so that we have all the method goodies
    functionEnvironmentProp, backendSecretResolver, functionEnvironmentTypeGenerator) {
        this.lambda = lambda;
        this.functionEnvironmentProp = functionEnvironmentProp;
        this.backendSecretResolver = backendSecretResolver;
        this.functionEnvironmentTypeGenerator = functionEnvironmentTypeGenerator;
        for (const [key, value] of Object.entries(this.functionEnvironmentProp)) {
            if (key === this.amplifySsmEnvConfigKey) {
                throw new Error(`${this.amplifySsmEnvConfigKey} is a reserved environment variable name`);
            }
            if (typeof value !== 'string') {
                const { branchSecretPath, sharedSecretPath } = this.backendSecretResolver.resolvePath(value);
                this.lambda.addEnvironment(key, this.ssmValuePlaceholderText);
                this.ssmEnvVars[branchSecretPath] = {
                    name: key,
                    sharedPath: sharedSecretPath,
                };
                this.ssmPaths.push(branchSecretPath, sharedSecretPath);
            }
            else {
                this.lambda.addEnvironment(key, value);
            }
            this.amplifyBackendEnvVarNames.push(key);
        }
        // add an environment variable for ssm parameter metadata that is resolved after initialization but before synth is finalized
        this.lambda.addEnvironment(this.amplifySsmEnvConfigKey, Lazy.string({
            produce: () => JSON.stringify(this.ssmEnvVars),
        }));
        this.lambda.node.addValidation({
            validate: () => {
                // only add the ssm access policy if there are ssm paths
                if (this.ssmPaths.length > 0) {
                    const ssmAccessPolicy = new PolicyStatement({
                        effect: Effect.ALLOW,
                        actions: ['ssm:GetParameters'],
                        resources: this.ssmPaths
                            .map((path) => (path.startsWith('/') ? path.slice(1) : path)) // the Arn formatter will add a leading slash between the resource and resourceName
                            .map((path) => Arn.format({
                            service: 'ssm',
                            resource: 'parameter',
                            resourceName: path,
                        }, Stack.of(this.lambda))),
                    });
                    this.lambda.grantPrincipal.addToPrincipalPolicy(ssmAccessPolicy);
                }
                return [];
            },
        });
        // Using CDK validation mechanism as a way to generate a typed process.env shim file at the end of synthesis
        this.lambda.node.addValidation({
            validate: () => {
                this.functionEnvironmentTypeGenerator.generateTypedProcessEnvShim(this.amplifyBackendEnvVarNames);
                return [];
            },
        });
    }
    /**
     * Adds an environment variable to the lambda whose value will be fetched from SSM at runtime
     * @param name The environment variable name
     * @param ssmPath The SSM path where the value is stored
     */
    addSsmEnvironmentEntry = (name, ssmPath) => {
        this.lambda.addEnvironment(name, this.ssmValuePlaceholderText);
        this.ssmPaths.push(ssmPath);
        this.ssmEnvVars[ssmPath] = { name };
        this.amplifyBackendEnvVarNames.push(name);
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZnVuY3Rpb25fZW52X3RyYW5zbGF0b3IuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvZnVuY3Rpb25fZW52X3RyYW5zbGF0b3IudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQ0EsT0FBTyxFQUFFLEdBQUcsRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFLE1BQU0sYUFBYSxDQUFDO0FBRy9DLE9BQU8sRUFBRSxNQUFNLEVBQUUsZUFBZSxFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFHOUQ7OztHQUdHO0FBQ0gsTUFBTSxPQUFPLDZCQUE2QjtJQWVyQjtJQUNBO0lBQ0E7SUFDQTtJQWpCRixRQUFRLEdBQWEsRUFBRSxDQUFDO0lBQ3hCLFVBQVUsR0FBZSxFQUFFLENBQUM7SUFFNUIsc0JBQXNCLEdBQUcsd0JBQXdCLENBQUM7SUFDbEQsdUJBQXVCLEdBQ3RDLHlDQUF5QyxDQUFDO0lBRTVDLCtEQUErRDtJQUM5Qyx5QkFBeUIsR0FBYSxFQUFFLENBQUM7SUFFMUQ7O09BRUc7SUFDSCxZQUNtQixNQUFzQixFQUFFLDZFQUE2RTtJQUNyRyx1QkFBK0QsRUFDL0QscUJBQTRDLEVBQzVDLGdDQUFrRTtRQUhsRSxXQUFNLEdBQU4sTUFBTSxDQUFnQjtRQUN0Qiw0QkFBdUIsR0FBdkIsdUJBQXVCLENBQXdDO1FBQy9ELDBCQUFxQixHQUFyQixxQkFBcUIsQ0FBdUI7UUFDNUMscUNBQWdDLEdBQWhDLGdDQUFnQyxDQUFrQztRQUVuRixLQUFLLE1BQU0sQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDLElBQUksTUFBTSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsdUJBQXVCLENBQUMsRUFBRTtZQUN2RSxJQUFJLEdBQUcsS0FBSyxJQUFJLENBQUMsc0JBQXNCLEVBQUU7Z0JBQ3ZDLE1BQU0sSUFBSSxLQUFLLENBQ2IsR0FBRyxJQUFJLENBQUMsc0JBQXNCLDBDQUEwQyxDQUN6RSxDQUFDO2FBQ0g7WUFDRCxJQUFJLE9BQU8sS0FBSyxLQUFLLFFBQVEs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QUFDLENBQUM7UUFDNUIsSUFBSSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsR0FBRyxFQUFFLElBQUksRUFBRSxDQUFDO1FBQ3BDLElBQUksQ0FBQyx5QkFBeUIsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDNUMsQ0FBQyxDQUFDO0NBQ0giLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCYWNrZW5kU2VjcmV0UmVzb2x2ZXIgfSBmcm9tICdAYXdzLWFtcGxpZnkvcGx1Z2luLXR5cGVzJztcbmltcG9ydCB7IEFybiwgTGF6eSwgU3RhY2sgfSBmcm9tICdhd3MtY2RrLWxpYic7XG5pbXBvcnQgeyBGdW5jdGlvblByb3BzIH0gZnJvbSAnLi9mYWN0b3J5LmpzJztcbmltcG9ydCB7IE5vZGVqc0Z1bmN0aW9uIH0gZnJvbSAnYXdzLWNkay1saWIvYXdzLWxhbWJkYS1ub2RlanMnO1xuaW1wb3J0IHsgRWZmZWN0LCBQb2xpY3lTdGF0ZW1lbnQgfSBmcm9tICdhd3MtY2RrLWxpYi9hd3MtaWFtJztcbmltcG9ydCB7IEZ1bmN0aW9uRW52aXJvbm1lbnRUeXBlR2VuZXJhdG9yIH0gZnJvbSAnLi9mdW5jdGlvbl9lbnZfdHlwZV9nZW5lcmF0b3IuanMnO1xuXG4vKipcbiAqIFRyYW5zbGF0ZXMgZnVuY3Rpb24gZW52aXJvbm1lbnQgcHJvcHMgaW50byBhcHByb3ByaWF0ZSBlbnZpcm9ubWVudCByZWNvcmRzIGFuZCBidWlsZHMgYSBwb2xpY3kgc3RhdGVtZW50XG4gKiBpbiBvcmRlciB0byByZXNvbHZlIHNlY3JldHMgaW4gZW52aXJvbm1lbnQgcHJvcHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBGdW5jdGlvbkVudmlyb25tZW50VHJhbnNsYXRvciB7XG4gIHByaXZhdGUgcmVhZG9ubHkgc3NtUGF0aHM6IHN0cmluZ1tdID0gW107XG4gIHByaXZhdGUgcmVhZG9ubHkgc3NtRW52VmFyczogU3NtRW52VmFycyA9IHt9O1xuXG4gIHByaXZhdGUgcmVhZG9ubHkgYW1wbGlmeVNzbUVudkNvbmZpZ0tleSA9ICdBTVBMSUZZX1NTTV9FTlZfQ09ORklHJztcbiAgcHJpdmF0ZSByZWFkb25seSBzc21WYWx1ZVBsYWNlaG9sZGVyVGV4dCA9XG4gICAgJzx2YWx1ZSB3aWxsIGJlIHJlc29sdmVkIGR1cmluZyBydW50aW1lPic7XG5cbiAgLy8gTGlzdCBvZiBlbnZpcm9ubWVudCB2YXJpYWJsZSBuYW1lcyBmb3IgdHlwZWQgc2hpbSBnZW5lcmF0aW9uXG4gIHByaXZhdGUgcmVhZG9ubHkgYW1wbGlmeUJhY2tlbmRFbnZWYXJOYW1lczogc3RyaW5nW10gPSBbXTtcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSB0cmFuc2xhdGVkIGVudmlyb25tZW50IHZhcmlhYmxlIHJlY29yZHNcbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgbGFtYmRhOiBOb2RlanNGdW5jdGlvbiwgLy8gd2UgbmVlZCB0byB1c2UgYSBzcGVjaWZpYyB0eXBlIGhlcmUgc28gdGhhdCB3ZSBoYXZlIGFsbCB0aGUgbWV0aG9kIGdvb2RpZXNcbiAgICBwcml2YXRlIHJlYWRvbmx5IGZ1bmN0aW9uRW52aXJvbm1lbnRQcm9wOiBSZXF1aXJlZDxGdW5jdGlvblByb3BzPlsnZW52aXJvbm1lbnQnXSxcbiAgICBwcml2YXRlIHJlYWRvbmx5IGJhY2tlbmRTZWNyZXRSZXNvbHZlcjogQmFja2VuZFNlY3JldFJlc29sdmVyLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgZnVuY3Rpb25FbnZpcm9ubWVudFR5cGVHZW5lcmF0b3I6IEZ1bmN0aW9uRW52aXJvbm1lbnRUeXBlR2VuZXJhdG9yXG4gICkge1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMuZnVuY3Rpb25FbnZpcm9ubWVudFByb3ApKSB7XG4gICAgICBpZiAoa2V5ID09PSB0aGlzLmFtcGxpZnlTc21FbnZDb25maWdLZXkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGAke3RoaXMuYW1wbGlmeVNzbUVudkNvbmZpZ0tleX0gaXMgYSByZXNlcnZlZCBlbnZpcm9ubWVudCB2YXJpYWJsZSBuYW1lYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uc3QgeyBicmFuY2hTZWNyZXRQYXRoLCBzaGFyZWRTZWNyZXRQYXRoIH0gPVxuICAgICAgICAgIHRoaXMuYmFja2VuZFNlY3JldFJlc29sdmVyLnJlc29sdmVQYXRoKHZhbHVlKTtcbiAgICAgICAgdGhpcy5sYW1iZGEuYWRkRW52aXJvbm1lbnQoa2V5LCB0aGlzLnNzbVZhbHVlUGxhY2Vob2xkZXJUZXh0KTtcbiAgICAgICAgdGhpcy5zc21FbnZWYXJzW2JyYW5jaFNlY3JldFBhdGhdID0ge1xuICAgICAgICAgIG5hbWU6IGtleSxcbiAgICAgICAgICBzaGFyZWRQYXRoOiBzaGFyZWRTZWNyZXRQYXRoLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNzbVBhdGhzLnB1c2goYnJhbmNoU2VjcmV0UGF0aCwgc2hhcmVkU2VjcmV0UGF0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxhbWJkYS5hZGRFbnZpcm9ubWVudChrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYW1wbGlmeUJhY2tlbmRFbnZWYXJOYW1lcy5wdXNoKGtleSk7XG4gICAgfVxuXG4gICAgLy8gYWRkIGFuIGVudmlyb25tZW50IHZhcmlhYmxlIGZvciBzc20gcGFyYW1ldGVyIG1ldGFkYXRhIHRoYXQgaXMgcmVzb2x2ZWQgYWZ0ZXIgaW5pdGlhbGl6YXRpb24gYnV0IGJlZm9yZSBzeW50aCBpcyBmaW5hbGl6ZWRcbiAgICB0aGlzLmxhbWJkYS5hZGRFbnZpcm9ubWVudChcbiAgICAgIHRoaXMuYW1wbGlmeVNzbUVudkNvbmZpZ0tleSxcbiAgICAgIExhenkuc3RyaW5nKHtcbiAgICAgICAgcHJvZHVjZTogKCkgPT4gSlNPTi5zdHJpbmdpZnkodGhpcy5zc21FbnZWYXJzKSxcbiAgICAgIH0pXG4gICAgKTtcblxuICAgIHRoaXMubGFtYmRhLm5vZGUuYWRkVmFsaWRhdGlvbih7XG4gICAgICB2YWxpZGF0ZTogKCkgPT4ge1xuICAgICAgICAvLyBvbmx5IGFkZCB0aGUgc3NtIGFjY2VzcyBwb2xpY3kgaWYgdGhlcmUgYXJlIHNzbSBwYXRoc1xuICAgICAgICBpZiAodGhpcy5zc21QYXRocy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY29uc3Qgc3NtQWNjZXNzUG9saWN5ID0gbmV3IFBvbGljeVN0YXRlbWVudCh7XG4gICAgICAgICAgICBlZmZlY3Q6IEVmZmVjdC5BTExPVyxcbiAgICAgICAgICAgIGFjdGlvbnM6IFsnc3NtOkdldFBhcmFtZXRlcnMnXSxcbiAgICAgICAgICAgIHJlc291cmNlczogdGhpcy5zc21QYXRoc1xuICAgICAgICAgICAgICAubWFwKChwYXRoKSA9PiAocGF0aC5zdGFydHNXaXRoKCcvJykgPyBwYXRoLnNsaWNlKDEpIDogcGF0aCkpIC8vIHRoZSBBcm4gZm9ybWF0dGVyIHdpbGwgYWRkIGEgbGVhZGluZyBzbGFzaCBiZXR3ZWVuIHRoZSByZXNvdXJjZSBhbmQgcmVzb3VyY2VOYW1lXG4gICAgICAgICAgICAgIC5tYXAoKHBhdGgpID0+XG4gICAgICAgICAgICAgICAgQXJuLmZvcm1hdChcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgc2VydmljZTogJ3NzbScsXG4gICAgICAgICAgICAgICAgICAgIHJlc291cmNlOiAncGFyYW1ldGVyJyxcbiAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2VOYW1lOiBwYXRoLFxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIFN0YWNrLm9mKHRoaXMubGFtYmRhKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLmxhbWJkYS5ncmFudFByaW5jaXBhbC5hZGRUb1ByaW5jaXBhbFBvbGljeShzc21BY2Nlc3NQb2xpY3kpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICAvLyBVc2luZyBDREsgdmFsaWRhdGlvbiBtZWNoYW5pc20gYXMgYSB3YXkgdG8gZ2VuZXJhdGUgYSB0eXBlZCBwcm9jZXNzLmVudiBzaGltIGZpbGUgYXQgdGhlIGVuZCBvZiBzeW50aGVzaXNcbiAgICB0aGlzLmxhbWJkYS5ub2RlLmFkZFZhbGlkYXRpb24oe1xuICAgICAgdmFsaWRhdGU6ICgpOiBzdHJpbmdbXSA9PiB7XG4gICAgICAgIHRoaXMuZnVuY3Rpb25FbnZpcm9ubWVudFR5cGVHZW5lcmF0b3IuZ2VuZXJhdGVUeXBlZFByb2Nlc3NFbnZTaGltKFxuICAgICAgICAgIHRoaXMuYW1wbGlmeUJhY2tlbmRFbnZWYXJOYW1lc1xuICAgICAgICApO1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYW4gZW52aXJvbm1lbnQgdmFyaWFibGUgdG8gdGhlIGxhbWJkYSB3aG9zZSB2YWx1ZSB3aWxsIGJlIGZldGNoZWQgZnJvbSBTU00gYXQgcnVudGltZVxuICAgKiBAcGFyYW0gbmFtZSBUaGUgZW52aXJvbm1lbnQgdmFyaWFibGUgbmFtZVxuICAgKiBAcGFyYW0gc3NtUGF0aCBUaGUgU1NNIHBhdGggd2hlcmUgdGhlIHZhbHVlIGlzIHN0b3JlZFxuICAgKi9cbiAgYWRkU3NtRW52aXJvbm1lbnRFbnRyeSA9IChuYW1lOiBzdHJpbmcsIHNzbVBhdGg6IHN0cmluZykgPT4ge1xuICAgIHRoaXMubGFtYmRhLmFkZEVudmlyb25tZW50KG5hbWUsIHRoaXMuc3NtVmFsdWVQbGFjZWhvbGRlclRleHQpO1xuICAgIHRoaXMuc3NtUGF0aHMucHVzaChzc21QYXRoKTtcbiAgICB0aGlzLnNzbUVudlZhcnNbc3NtUGF0aF0gPSB7IG5hbWUgfTtcbiAgICB0aGlzLmFtcGxpZnlCYWNrZW5kRW52VmFyTmFtZXMucHVzaChuYW1lKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBEZWZpbmVzIG1ldGFkYXRhIGFyb3VuZCBlbnZpcm9ubWVudCB2YXJpYWJsZSB2YWx1ZXMgdGhhdCBhcmUgZmV0Y2hlZCBmcm9tIFNTTSBkdXJpbmcgcnVudGltZSBvZiB0aGUgbGFtYmRhIGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCB0eXBlIFNzbUVudlZhcnMgPSB7XG4gIC8qKlxuICAgKiBUaGUgcmVjb3JkIGtleSBuYW1lcyBhcmUgdGhlIGJyYW5jaC1zcGVjaWZpYyBTU00gcGF0aHMgdG8gZmV0Y2ggdGhlIHZhbHVlIGZyb21cbiAgICovXG4gIFticmFuY2hQYXRoOiBzdHJpbmddOiB7XG4gICAgLyoqXG4gICAgICogVGhlIGVudmlyb25tZW50IHZhcmlhYmxlIG5hbWUgdG8gcGxhY2UgdGhlIHJlc29sdmVkIHZhbHVlIGluXG4gICAgICovXG4gICAgbmFtZTogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIEFuIG9wdGlvbmFsIFwiZmFsbGJhY2tcIiBTU00gcGF0aCB3aGVyZSB0aGUgdmFsdWUgd2lsbCBiZSBsb29rZWQgdXAgaWYgbm90IGZvdW5kIGF0IHRoZSBicmFuY2gtc3BlY2lmaWMgcGF0aFxuICAgICAqL1xuICAgIHNoYXJlZFBhdGg/OiBzdHJpbmc7XG4gIH07XG59O1xuIl19
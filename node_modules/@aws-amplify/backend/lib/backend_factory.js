import { NestedStackResolver, } from './engine/nested_stack_resolver.js';
import { SingletonConstructContainer } from './engine/singleton_construct_container.js';
import { ToggleableImportPathVerifier } from './engine/validations/toggleable_import_path_verifier.js';
import { AttributionMetadataStorage, StackMetadataBackendOutputStorageStrategy, } from '@aws-amplify/backend-output-storage';
import { createDefaultStack } from './default_stack_factory.js';
import { getBackendIdentifier } from './backend_identifier.js';
import { platformOutputKey } from '@aws-amplify/backend-output-schemas';
import { fileURLToPath } from 'url';
import { AmplifyBranchLinkerConstruct } from './engine/branch-linker/branch_linker_construct.js';
import { ClientConfigVersionOption, } from '@aws-amplify/client-config';
import { CustomOutputsAccumulator } from './engine/custom_outputs_accumulator.js';
import { ObjectAccumulator } from '@aws-amplify/platform-core';
import { DefaultResourceNameValidator } from './engine/validations/default_resource_name_validator.js';
// Be very careful editing this value. It is the value used in the BI metrics to attribute stacks as Amplify root stacks
const rootStackTypeIdentifier = 'root';
// Client config version that is used by `backend.addOutput()`
const DEFAULT_CLIENT_CONFIG_VERSION_FOR_BACKEND_ADD_OUTPUT = ClientConfigVersionOption.V1;
/**
 * Factory that collects and instantiates all the Amplify backend constructs
 */
export class BackendFactory {
    /**
     * These are the resolved CDK constructs that are created by the inputs to the constructor
     * Used for overriding properties of underlying CDK constructs or to reference in custom CDK code
     */
    resources;
    stackResolver;
    customOutputsAccumulator;
    /**
     * Initialize an Amplify backend with the given construct factories and in the given CDK App.
     * If no CDK App is specified a new one is created
     */
    constructor(constructFactories, stack = createDefaultStack()) {
        new AttributionMetadataStorage().storeAttributionMetadata(stack, rootStackTypeIdentifier, fileURLToPath(new URL('../package.json', import.meta.url)));
        this.stackResolver = new NestedStackResolver(stack, new AttributionMetadataStorage());
        const constructContainer = new SingletonConstructContainer(this.stackResolver);
        const outputStorageStrategy = new StackMetadataBackendOutputStorageStrategy(stack);
        this.customOutputsAccumulator = new CustomOutputsAccumulator(outputStorageStrategy, new ObjectAccumulator({}));
        const backendId = getBackendIdentifier(stack);
        outputStorageStrategy.addBackendOutputEntry(platformOutputKey, {
            version: '1',
            payload: {
                deploymentType: backendId.type,
                region: stack.region,
            },
        });
        const shouldEnableBranchLinker = backendId.type === 'branch';
        if (shouldEnableBranchLinker) {
            new AmplifyBranchLinkerConstruct(stack, backendId);
        }
        const importPathVerifier = new ToggleableImportPathVerifier();
        const resourceNameValidator = new DefaultResourceNameValidator();
        // register providers but don't actually execute anything yet
        Object.values(constructFactories).forEach((factory) => {
            if (typeof factory.provides === 'string') {
                constructContainer.registerConstructFactory(factory.provides, factory);
            }
        });
        // now invoke all the factories and collect the constructs into this.resources
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        this.resources = {};
        Object.entries(constructFactories).forEach(([resourceName, constructFactory]) => {
            // The type inference on this.resources is not happy about this assignment because it doesn't know the exact type of .getInstance()
            // However, the assignment is okay because we are iterating over the entries of constructFactories and assigning the resource name to the corresponding instance
            this.resources[resourceName] = constructFactory.getInstance({
                constructContainer,
                outputStorageStrategy,
                importPathVerifier,
                resourceNameValidator,
            }
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            );
        });
    }
    /**
     * Returns a CDK stack within the Amplify project that can be used for creating custom resources.
     * If a stack has already been created with "name" then an error is thrown.
     */
    createStack = (name) => {
        return this.stackResolver.createCustomStack(name);
    };
    addOutput = (clientConfigPart) => {
        const { version } = clientConfigPart;
        if (!version) {
            clientConfigPart.version =
                DEFAULT_CLIENT_CONFIG_VERSION_FOR_BACKEND_ADD_OUTPUT;
        }
        this.customOutputsAccumulator.addOutput(clientConfigPart);
    };
}
/**
 * Creates a new Amplify backend instance and returns it
 * @param constructFactories - list of backend factories such as those created by `defineAuth` or `defineData`
 */
export const defineBackend = (constructFactories) => {
    const backend = new BackendFactory(constructFactories);
    return {
        ...backend.resources,
        createStack: backend.createStack,
        addOutput: backend.addOutput,
    };
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFja2VuZF9mYWN0b3J5LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL2JhY2tlbmRfZmFjdG9yeS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFNQSxPQUFPLEVBQ0wsbUJBQW1CLEdBRXBCLE1BQU0sbUNBQW1DLENBQUM7QUFDM0MsT0FBTyxFQUFFLDJCQUEyQixFQUFFLE1BQU0sMkNBQTJDLENBQUM7QUFDeEYsT0FBTyxFQUFFLDRCQUE0QixFQUFFLE1BQU0seURBQXlELENBQUM7QUFDdkcsT0FBTyxFQUNMLDBCQUEwQixFQUMxQix5Q0FBeUMsR0FDMUMsTUFBTSxxQ0FBcUMsQ0FBQztBQUM3QyxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSw0QkFBNEIsQ0FBQztBQUNoRSxPQUFPLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQztBQUMvRCxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxxQ0FBcUMsQ0FBQztBQUN4RSxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sS0FBSyxDQUFDO0FBRXBDLE9BQU8sRUFBRSw0QkFBNEIsRUFBRSxNQUFNLG1EQUFtRCxDQUFDO0FBQ2pHLE9BQU8sRUFFTCx5QkFBeUIsR0FDMUIsTUFBTSw0QkFBNEIsQ0FBQztBQUNwQyxPQUFPLEVBQUUsd0JBQXdCLEVBQUUsTUFBTSx3Q0FBd0MsQ0FBQztBQUNsRixPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSw0QkFBNEIsQ0FBQztBQUMvRCxPQUFPLEVBQUUsNEJBQTRCLEVBQUUsTUFBTSx5REFBeUQsQ0FBQztBQUV2Ryx3SEFBd0g7QUFDeEgsTUFBTSx1QkFBdUIsR0FBRyxNQUFNLENBQUM7QUFFdkMsOERBQThEO0FBQzlELE1BQU0sb0RBQW9ELEdBQ3hELHlCQUF5QixDQUFDLEVBQUUsQ0FBQztBQUUvQjs7R0FFRztBQUNILE1BQU0sT0FBTyxjQUFjO0lBR3pCOzs7T0FHRztJQUNNLFNBQVMsQ0FFaEI7SUFFZSxhQUFhLENBQWdCO0lB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O1FBQ0QsSUFBSSxDQUFDLHdCQUF3QixDQUFDLFNBQVMsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO0lBQzVELENBQUMsQ0FBQztDQUNIO0FBRUQ7OztHQUdHO0FBQ0gsTUFBTSxDQUFDLE1BQU0sYUFBYSxHQUFHLENBQzNCLGtCQUFxQixFQUNULEVBQUU7SUFDZCxNQUFNLE9BQU8sR0FBRyxJQUFJLGNBQWMsQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO0lBQ3ZELE9BQU87UUFDTCxHQUFHLE9BQU8sQ0FBQyxTQUFTO1FBQ3BCLFdBQVcsRUFBRSxPQUFPLENBQUMsV0FBVztRQUNoQyxTQUFTLEVBQUUsT0FBTyxDQUFDLFNBQVM7S0FDN0IsQ0FBQztBQUNKLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIENvbnN0cnVjdEZhY3RvcnksXG4gIERlZXBQYXJ0aWFsQW1wbGlmeUdlbmVyYXRlZENvbmZpZ3MsXG4gIFJlc291cmNlUHJvdmlkZXIsXG59IGZyb20gJ0Bhd3MtYW1wbGlmeS9wbHVnaW4tdHlwZXMnO1xuaW1wb3J0IHsgU3RhY2sgfSBmcm9tICdhd3MtY2RrLWxpYic7XG5pbXBvcnQge1xuICBOZXN0ZWRTdGFja1Jlc29sdmVyLFxuICBTdGFja1Jlc29sdmVyLFxufSBmcm9tICcuL2VuZ2luZS9uZXN0ZWRfc3RhY2tfcmVzb2x2ZXIuanMnO1xuaW1wb3J0IHsgU2luZ2xldG9uQ29uc3RydWN0Q29udGFpbmVyIH0gZnJvbSAnLi9lbmdpbmUvc2luZ2xldG9uX2NvbnN0cnVjdF9jb250YWluZXIuanMnO1xuaW1wb3J0IHsgVG9nZ2xlYWJsZUltcG9ydFBhdGhWZXJpZmllciB9IGZyb20gJy4vZW5naW5lL3ZhbGlkYXRpb25zL3RvZ2dsZWFibGVfaW1wb3J0X3BhdGhfdmVyaWZpZXIuanMnO1xuaW1wb3J0IHtcbiAgQXR0cmlidXRpb25NZXRhZGF0YVN0b3JhZ2UsXG4gIFN0YWNrTWV0YWRhdGFCYWNrZW5kT3V0cHV0U3RvcmFnZVN0cmF0ZWd5LFxufSBmcm9tICdAYXdzLWFtcGxpZnkvYmFja2VuZC1vdXRwdXQtc3RvcmFnZSc7XG5pbXBvcnQgeyBjcmVhdGVEZWZhdWx0U3RhY2sgfSBmcm9tICcuL2RlZmF1bHRfc3RhY2tfZmFjdG9yeS5qcyc7XG5pbXBvcnQgeyBnZXRCYWNrZW5kSWRlbnRpZmllciB9IGZyb20gJy4vYmFja2VuZF9pZGVudGlmaWVyLmpzJztcbmltcG9ydCB7IHBsYXRmb3JtT3V0cHV0S2V5IH0gZnJvbSAnQGF3cy1hbXBsaWZ5L2JhY2tlbmQtb3V0cHV0LXNjaGVtYXMnO1xuaW1wb3J0IHsgZmlsZVVSTFRvUGF0aCB9IGZyb20gJ3VybCc7XG5pbXBvcnQgeyBCYWNrZW5kLCBEZWZpbmVCYWNrZW5kUHJvcHMgfSBmcm9tICcuL2JhY2tlbmQuanMnO1xuaW1wb3J0IHsgQW1wbGlmeUJyYW5jaExpbmtlckNvbnN0cnVjdCB9IGZyb20gJy4vZW5naW5lL2JyYW5jaC1saW5rZXIvYnJhbmNoX2xpbmtlcl9jb25zdHJ1Y3QuanMnO1xuaW1wb3J0IHtcbiAgQ2xpZW50Q29uZmlnLFxuICBDbGllbnRDb25maWdWZXJzaW9uT3B0aW9uLFxufSBmcm9tICdAYXdzLWFtcGxpZnkvY2xpZW50LWNvbmZpZyc7XG5pbXBvcnQgeyBDdXN0b21PdXRwdXRzQWNjdW11bGF0b3IgfSBmcm9tICcuL2VuZ2luZS9jdXN0b21fb3V0cHV0c19hY2N1bXVsYXRvci5qcyc7XG5pbXBvcnQgeyBPYmplY3RBY2N1bXVsYXRvciB9IGZyb20gJ0Bhd3MtYW1wbGlmeS9wbGF0Zm9ybS1jb3JlJztcbmltcG9ydCB7IERlZmF1bHRSZXNvdXJjZU5hbWVWYWxpZGF0b3IgfSBmcm9tICcuL2VuZ2luZS92YWxpZGF0aW9ucy9kZWZhdWx0X3Jlc291cmNlX25hbWVfdmFsaWRhdG9yLmpzJztcblxuLy8gQmUgdmVyeSBjYXJlZnVsIGVkaXRpbmcgdGhpcyB2YWx1ZS4gSXQgaXMgdGhlIHZhbHVlIHVzZWQgaW4gdGhlIEJJIG1ldHJpY3MgdG8gYXR0cmlidXRlIHN0YWNrcyBhcyBBbXBsaWZ5IHJvb3Qgc3RhY2tzXG5jb25zdCByb290U3RhY2tUeXBlSWRlbnRpZmllciA9ICdyb290JztcblxuLy8gQ2xpZW50IGNvbmZpZyB2ZXJzaW9uIHRoYXQgaXMgdXNlZCBieSBgYmFja2VuZC5hZGRPdXRwdXQoKWBcbmNvbnN0IERFRkFVTFRfQ0xJRU5UX0NPTkZJR19WRVJTSU9OX0ZPUl9CQUNLRU5EX0FERF9PVVRQVVQgPVxuICBDbGllbnRDb25maWdWZXJzaW9uT3B0aW9uLlYxO1xuXG4vKipcbiAqIEZhY3RvcnkgdGhhdCBjb2xsZWN0cyBhbmQgaW5zdGFudGlhdGVzIGFsbCB0aGUgQW1wbGlmeSBiYWNrZW5kIGNvbnN0cnVjdHNcbiAqL1xuZXhwb3J0IGNsYXNzIEJhY2tlbmRGYWN0b3J5PFxuICBUIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgQ29uc3RydWN0RmFjdG9yeTxSZXNvdXJjZVByb3ZpZGVyPj5cbj4ge1xuICAvKipcbiAgICogVGhlc2UgYXJlIHRoZSByZXNvbHZlZCBDREsgY29uc3RydWN0cyB0aGF0IGFyZSBjcmVhdGVkIGJ5IHRoZSBpbnB1dHMgdG8gdGhlIGNvbnN0cnVjdG9yXG4gICAqIFVzZWQgZm9yIG92ZXJyaWRpbmcgcHJvcGVydGllcyBvZiB1bmRlcmx5aW5nIENESyBjb25zdHJ1Y3RzIG9yIHRvIHJlZmVyZW5jZSBpbiBjdXN0b20gQ0RLIGNvZGVcbiAgICovXG4gIHJlYWRvbmx5IHJlc291cmNlczoge1xuICAgIFtLIGluIGtleW9mIFRdOiBSZXR1cm5UeXBlPFRbS11bJ2dldEluc3RhbmNlJ10+O1xuICB9O1xuXG4gIHByaXZhdGUgcmVhZG9ubHkgc3RhY2tSZXNvbHZlcjogU3RhY2tSZXNvbHZlcjtcbiAgcHJpdmF0ZSByZWFkb25seSBjdXN0b21PdXRwdXRzQWNjdW11bGF0b3I6IEN1c3RvbU91dHB1dHNBY2N1bXVsYXRvcjtcbiAgLyoqXG4gICAqIEluaXRpYWxpemUgYW4gQW1wbGlmeSBiYWNrZW5kIHdpdGggdGhlIGdpdmVuIGNvbnN0cnVjdCBmYWN0b3JpZXMgYW5kIGluIHRoZSBnaXZlbiBDREsgQXBwLlxuICAgKiBJZiBubyBDREsgQXBwIGlzIHNwZWNpZmllZCBhIG5ldyBvbmUgaXMgY3JlYXRlZFxuICAgKi9cbiAgY29uc3RydWN0b3IoY29uc3RydWN0RmFjdG9yaWVzOiBULCBzdGFjazogU3RhY2sgPSBjcmVhdGVEZWZhdWx0U3RhY2soKSkge1xuICAgIG5ldyBBdHRyaWJ1dGlvbk1ldGFkYXRhU3RvcmFnZSgpLnN0b3JlQXR0cmlidXRpb25NZXRhZGF0YShcbiAgICAgIHN0YWNrLFxuICAgICAgcm9vdFN0YWNrVHlwZUlkZW50aWZpZXIsXG4gICAgICBmaWxlVVJMVG9QYXRoKG5ldyBVUkwoJy4uL3BhY2thZ2UuanNvbicsIGltcG9ydC5tZXRhLnVybCkpXG4gICAgKTtcbiAgICB0aGlzLnN0YWNrUmVzb2x2ZXIgPSBuZXcgTmVzdGVkU3RhY2tSZXNvbHZlcihcbiAgICAgIHN0YWNrLFxuICAgICAgbmV3IEF0dHJpYnV0aW9uTWV0YWRhdGFTdG9yYWdlKClcbiAgICApO1xuXG4gICAgY29uc3QgY29uc3RydWN0Q29udGFpbmVyID0gbmV3IFNpbmdsZXRvbkNvbnN0cnVjdENvbnRhaW5lcihcbiAgICAgIHRoaXMuc3RhY2tSZXNvbHZlclxuICAgICk7XG5cbiAgICBjb25zdCBvdXRwdXRTdG9yYWdlU3RyYXRlZ3kgPSBuZXcgU3RhY2tNZXRhZGF0YUJhY2tlbmRPdXRwdXRTdG9yYWdlU3RyYXRlZ3koXG4gICAgICBzdGFja1xuICAgICk7XG5cbiAgICB0aGlzLmN1c3RvbU91dHB1dHNBY2N1bXVsYXRvciA9IG5ldyBDdXN0b21PdXRwdXRzQWNjdW11bGF0b3IoXG4gICAgICBvdXRwdXRTdG9yYWdlU3RyYXRlZ3ksXG4gICAgICBuZXcgT2JqZWN0QWNjdW11bGF0b3I8Q2xpZW50Q29uZmlnPih7fSlcbiAgICApO1xuXG4gICAgY29uc3QgYmFja2VuZElkID0gZ2V0QmFja2VuZElkZW50aWZpZXIoc3RhY2spO1xuICAgIG91dHB1dFN0b3JhZ2VTdHJhdGVneS5hZGRCYWNrZW5kT3V0cHV0RW50cnkocGxhdGZvcm1PdXRwdXRLZXksIHtcbiAgICAgIHZlcnNpb246ICcxJyxcbiAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgZGVwbG95bWVudFR5cGU6IGJhY2tlbmRJZC50eXBlLFxuICAgICAgICByZWdpb246IHN0YWNrLnJlZ2lvbixcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICBjb25zdCBzaG91bGRFbmFibGVCcmFuY2hMaW5rZXIgPSBiYWNrZW5kSWQudHlwZSA9PT0gJ2JyYW5jaCc7XG5cbiAgICBpZiAoc2hvdWxkRW5hYmxlQnJhbmNoTGlua2VyKSB7XG4gICAgICBuZXcgQW1wbGlmeUJyYW5jaExpbmtlckNvbnN0cnVjdChzdGFjaywgYmFja2VuZElkKTtcbiAgICB9XG5cbiAgICBjb25zdCBpbXBvcnRQYXRoVmVyaWZpZXIgPSBuZXcgVG9nZ2xlYWJsZUltcG9ydFBhdGhWZXJpZmllcigpO1xuXG4gICAgY29uc3QgcmVzb3VyY2VOYW1lVmFsaWRhdG9yID0gbmV3IERlZmF1bHRSZXNvdXJjZU5hbWVWYWxpZGF0b3IoKTtcblxuICAgIC8vIHJlZ2lzdGVyIHByb3ZpZGVycyBidXQgZG9uJ3QgYWN0dWFsbHkgZXhlY3V0ZSBhbnl0aGluZyB5ZXRcbiAgICBPYmplY3QudmFsdWVzKGNvbnN0cnVjdEZhY3RvcmllcykuZm9yRWFjaCgoZmFjdG9yeSkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBmYWN0b3J5LnByb3ZpZGVzID09PSAnc3RyaW5nJykge1xuICAgICAgICBjb25zdHJ1Y3RDb250YWluZXIucmVnaXN0ZXJDb25zdHJ1Y3RGYWN0b3J5KGZhY3RvcnkucHJvdmlkZXMsIGZhY3RvcnkpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gbm93IGludm9rZSBhbGwgdGhlIGZhY3RvcmllcyBhbmQgY29sbGVjdCB0aGUgY29uc3RydWN0cyBpbnRvIHRoaXMucmVzb3VyY2VzXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICB0aGlzLnJlc291cmNlcyA9IHt9IGFzIGFueTtcbiAgICBPYmplY3QuZW50cmllcyhjb25zdHJ1Y3RGYWN0b3JpZXMpLmZvckVhY2goXG4gICAgICAoW3Jlc291cmNlTmFtZSwgY29uc3RydWN0RmFjdG9yeV0pID0+IHtcbiAgICAgICAgLy8gVGhlIHR5cGUgaW5mZXJlbmNlIG9uIHRoaXMucmVzb3VyY2VzIGlzIG5vdCBoYXBweSBhYm91dCB0aGlzIGFzc2lnbm1lbnQgYmVjYXVzZSBpdCBkb2Vzbid0IGtub3cgdGhlIGV4YWN0IHR5cGUgb2YgLmdldEluc3RhbmNlKClcbiAgICAgICAgLy8gSG93ZXZlciwgdGhlIGFzc2lnbm1lbnQgaXMgb2theSBiZWNhdXNlIHdlIGFyZSBpdGVyYXRpbmcgb3ZlciB0aGUgZW50cmllcyBvZiBjb25zdHJ1Y3RGYWN0b3JpZXMgYW5kIGFzc2lnbmluZyB0aGUgcmVzb3VyY2UgbmFtZSB0byB0aGUgY29ycmVzcG9uZGluZyBpbnN0YW5jZVxuICAgICAgICB0aGlzLnJlc291cmNlc1tyZXNvdXJjZU5hbWUgYXMga2V5b2YgVF0gPSBjb25zdHJ1Y3RGYWN0b3J5LmdldEluc3RhbmNlKFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0cnVjdENvbnRhaW5lcixcbiAgICAgICAgICAgIG91dHB1dFN0b3JhZ2VTdHJhdGVneSxcbiAgICAgICAgICAgIGltcG9ydFBhdGhWZXJpZmllcixcbiAgICAgICAgICAgIHJlc291cmNlTmFtZVZhbGlkYXRvcixcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgKSBhcyBhbnk7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgQ0RLIHN0YWNrIHdpdGhpbiB0aGUgQW1wbGlmeSBwcm9qZWN0IHRoYXQgY2FuIGJlIHVzZWQgZm9yIGNyZWF0aW5nIGN1c3RvbSByZXNvdXJjZXMuXG4gICAqIElmIGEgc3RhY2sgaGFzIGFscmVhZHkgYmVlbiBjcmVhdGVkIHdpdGggXCJuYW1lXCIgdGhlbiBhbiBlcnJvciBpcyB0aHJvd24uXG4gICAqL1xuICBjcmVhdGVTdGFjayA9IChuYW1lOiBzdHJpbmcpOiBTdGFjayA9PiB7XG4gICAgcmV0dXJuIHRoaXMuc3RhY2tSZXNvbHZlci5jcmVhdGVDdXN0b21TdGFjayhuYW1lKTtcbiAgfTtcblxuICBhZGRPdXRwdXQgPSAoXG4gICAgY2xpZW50Q29uZmlnUGFydDogRGVlcFBhcnRpYWxBbXBsaWZ5R2VuZXJhdGVkQ29uZmlnczxDbGllbnRDb25maWc+XG4gICkgPT4ge1xuICAgIGNvbnN0IHsgdmVyc2lvbiB9ID0gY2xpZW50Q29uZmlnUGFydDtcbiAgICBpZiAoIXZlcnNpb24pIHtcbiAgICAgIGNsaWVudENvbmZpZ1BhcnQudmVyc2lvbiA9XG4gICAgICAgIERFRkFVTFRfQ0xJRU5UX0NPTkZJR19WRVJTSU9OX0ZPUl9CQUNLRU5EX0FERF9PVVRQVVQ7XG4gICAgfVxuICAgIHRoaXMuY3VzdG9tT3V0cHV0c0FjY3VtdWxhdG9yLmFkZE91dHB1dChjbGllbnRDb25maWdQYXJ0KTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IEFtcGxpZnkgYmFja2VuZCBpbnN0YW5jZSBhbmQgcmV0dXJucyBpdFxuICogQHBhcmFtIGNvbnN0cnVjdEZhY3RvcmllcyAtIGxpc3Qgb2YgYmFja2VuZCBmYWN0b3JpZXMgc3VjaCBhcyB0aG9zZSBjcmVhdGVkIGJ5IGBkZWZpbmVBdXRoYCBvciBgZGVmaW5lRGF0YWBcbiAqL1xuZXhwb3J0IGNvbnN0IGRlZmluZUJhY2tlbmQgPSA8VCBleHRlbmRzIERlZmluZUJhY2tlbmRQcm9wcz4oXG4gIGNvbnN0cnVjdEZhY3RvcmllczogVFxuKTogQmFja2VuZDxUPiA9PiB7XG4gIGNvbnN0IGJhY2tlbmQgPSBuZXcgQmFja2VuZEZhY3RvcnkoY29uc3RydWN0RmFjdG9yaWVzKTtcbiAgcmV0dXJuIHtcbiAgICAuLi5iYWNrZW5kLnJlc291cmNlcyxcbiAgICBjcmVhdGVTdGFjazogYmFja2VuZC5jcmVhdGVTdGFjayxcbiAgICBhZGRPdXRwdXQ6IGJhY2tlbmQuYWRkT3V0cHV0LFxuICB9O1xufTtcbiJdfQ==
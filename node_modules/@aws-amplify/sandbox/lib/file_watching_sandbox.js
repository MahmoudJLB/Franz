import debounce from 'debounce-promise';
import parcelWatcher from '@parcel/watcher';
import parseGitIgnore from 'parse-gitignore';
import path from 'path';
import fs from 'fs';
import _open from 'open';
// EventEmitter is a class name and expected to have PascalCase
// eslint-disable-next-line @typescript-eslint/naming-convention
import EventEmitter from 'events';
import { DescribeStacksCommand, } from '@aws-sdk/client-cloudformation';
import { AmplifyPrompter, LogLevel, format, } from '@aws-amplify/cli-core';
import { createFilesChangesTracker, } from './files_changes_tracker.js';
import { AmplifyError, AmplifyUserError, BackendIdentifierConversions, } from '@aws-amplify/platform-core';
export const CDK_BOOTSTRAP_STACK_NAME = 'CDKToolkit';
export const CDK_BOOTSTRAP_VERSION_KEY = 'BootstrapVersion';
export const CDK_MIN_BOOTSTRAP_VERSION = 6;
/**
 * Constructs Amplify Console bootstrap URL for a given region
 * @param region AWS region
 * @returns Amplify Console bootstrap URL
 */
export const getBootstrapUrl = (region) => `https://${region}.console.aws.amazon.com/amplify/create/bootstrap?region=${region}`;
/**
 * Runs a file watcher and deploys
 */
export class FileWatchingSandbox extends EventEmitter {
    backendIdSandboxResolver;
    executor;
    cfnClient;
    printer;
    open;
    watcherSubscription;
    outputFilesExcludedFromWatch = ['.amplify'];
    filesChangesTracker;
    /**
     * Creates a watcher process for this instance
     */
    constructor(backendIdSandboxResolver, executor, cfnClient, printer, open = _open) {
        process.once('SIGINT', () => void this.stop());
        process.once('SIGTERM', () => void this.stop());
        super();
        this.backendIdSandboxResolver = backendIdSandboxResolver;
        this.executor = executor;
        this.cfnClient = cfnClient;
        this.printer = printer;
        this.open = open;
    }
    /**
     * @inheritdoc
     */
    emit(eventName, ...args) {
        return super.emit(eventName, ...args);
    }
    /**
     * @inheritdoc
     */
    on(eventName, listener) {
        return super.on(eventName, listener);
    }
    /**
     * @inheritdoc
     */
    start = async (options) => {
        const watchDir = options.dir ?? './amplify';
        const watchForChanges = options.watchForChanges ?? true;
        if (!fs.existsSync(watchDir)) {
            throw new AmplifyUserError('PathNotFoundError', {
                message: `${watchDir} does not exist.`,
                resolution: 'Make sure you are running this command from your project root directory.',
            });
        }
        this.filesChangesTracker = await createFilesChangesTracker(watchDir);
        const bootstrapped = await this.isBootstrapped();
        if (!bootstrapped) {
            this.printer.log('The given region has not been bootstrapped. Sign in to console as a Root user or Admin to complete the bootstrap process, then restart the sandbox.');
            // get region from an available sdk client;
            const region = await this.cfnClient.config.region();
            await this.open(getBootstrapUrl(region));
            return;
        }
        const ignoredPaths = this.getGitIgnoredPaths();
        this.outputFilesExcludedFromWatch =
            this.outputFilesExcludedFromWatch.concat(...ignoredPaths);
        await this.printSandboxNameInfo(options.identifier);
        // Since 'cdk deploy' is a relatively slow operation for a 'watch' process,
        // introduce a concurrency latch that tracks the state.
        // This way, if file change events arrive when a 'cdk deploy' is still executing,
        // we will batch them, and trigger another 'cdk deploy' after the current one finishes,
        // making sure 'cdk deploy's  always execute one at a time.
        // Here's a diagram showing the state transitions:
        // --------    file changed     --------------    file changed     --------------  file changed
        // |      | ------------------> |            | ------------------> |            | --------------|
        // | open |                     | deploying  |                     |   queued   |               |
        // |      | <------------------ |            | <------------------ |            | <-------------|
        // --------  'cdk deploy' done  --------------  'cdk deploy' done  --------------
        let latch = 'open';
        const deployAndWatch = debounce(async () => {
            latch = 'deploying';
            await this.deploy(options);
            // If latch is still 'deploying' after the 'await', that's fine,
            // but if it's 'queued', that means we need to deploy again
            while (latch === 'queued') {
                // TypeScript doesn't realize latch can change between 'awaits' ¯\_(ツ)_/¯,
                // and thinks the above 'while' condition is always 'false' without the cast
                latch = 'deploying';
                this.printer.log("[Sandbox] Detected file changes while previous deployment was in progress. Invoking 'sandbox' again");
                await this.deploy(options);
            }
            latch = 'open';
            this.emitWatching();
        });
        if (watchForChanges) {
            this.watcherSubscription = await parcelWatcher.subscribe(watchDir, async (_, events) => {
                // Log and track file changes.
                await Promise.all(events.map(({ type: eventName, path }) => {
                    this.filesChangesTracker.trackFileChange(path);
                    this.printer.log(`[Sandbox] Triggered due to a file ${eventName} event: ${path}`);
                }));
                if (latch === 'open') {
                    await deployAndWatch();
                }
                else {
                    // this means latch is either 'deploying' or 'queued'
                    latch = 'queued';
                    this.printer.log('[Sandbox] Previous deployment is still in progress. ' +
                        'Will queue for another deployment after this one finishes');
                }
            }, {
                ignore: this.outputFilesExcludedFromWatch.concat(...(options.exclude ?? [])),
            });
            // Start the first full deployment without waiting for a file change
            await deployAndWatch();
        }
        else {
            await this.deploy(options);
        }
    };
    /**
     * @inheritdoc
     */
    stop = async () => {
        this.printer.log(`[Sandbox] Shutting down`, LogLevel.DEBUG);
        // can be undefined if command exits before subscription
        await this.watcherSubscription?.unsubscribe();
    };
    /**
     * @inheritdoc
     */
    delete = async (options) => {
        this.printer.log('[Sandbox] Deleting all the resources in the sandbox environment...');
        await this.executor.destroy(await this.backendIdSandboxResolver(options.identifier));
        this.emit('successfulDeletion');
        this.printer.log('[Sandbox] Finished deleting.');
    };
    shouldValidateAppSources = () => {
        const snapshot = this.filesChangesTracker.getAndResetSnapshot();
        // if zero files changed this indicates initial deployment
        const shouldValidateOnColdStart = snapshot.hadTypeScriptFilesAtStart &&
            !snapshot.didAnyFileChangeSinceStart;
        return (shouldValidateOnColdStart ||
            snapshot.didAnyTypeScriptFileChangeSinceLastSnapshot);
    };
    deploy = async (options) => {
        try {
            const deployResult = await this.executor.deploy(await this.backendIdSandboxResolver(options.identifier), 
            // It's important to pass this as callback so that debounce does
            // not reset tracker prematurely
            this.shouldValidateAppSources);
            this.printer.log('[Sandbox] Deployment successful', LogLevel.DEBUG);
            this.emit('successfulDeployment', deployResult);
        }
        catch (error) {
            // Print a meaningful message
            this.printer.print(format.error(this.getErrorMessage(error)));
            this.emit('failedDeployment', error);
            // If the error is because of a non-allowed destructive change such as
            // https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-cognito-userpool.html#cfn-cognito-userpool-aliasattributes
            // offer to recreate the sandbox or revert the change
            if (error instanceof AmplifyError &&
                error.name === 'CFNUpdateNotSupportedError') {
                await this.handleUnsupportedDestructiveChanges(options);
            }
            // else do not propagate and let the sandbox continue to run
        }
    };
    reset = async (options) => {
        await this.delete({ identifier: options.identifier });
        await this.start(options);
    };
    /**
     * Just a shorthand console log to indicate whenever watcher is going idle
     */
    emitWatching = () => {
        this.printer.log(`[Sandbox] Watching for file changes...`);
    };
    /**
     * Reads and parses .gitignore file and returns the list of paths
     */
    getGitIgnoredPaths = () => {
        const gitIgnoreFilePath = path.join(process.cwd(), '.gitignore');
        if (fs.existsSync(gitIgnoreFilePath)) {
            return parseGitIgnore
                .parse(gitIgnoreFilePath)
                .patterns.map((pattern) => pattern.startsWith('/') ? pattern.substring(1) : pattern)
                .filter((pattern) => {
                if (pattern.startsWith('!')) {
                    this.printer.log(`[Sandbox] Pattern ${pattern} found in .gitignore. "${pattern.substring(1)}" will not be watched if other patterns in .gitignore are excluding it.`);
                    return false;
                }
                return true;
            });
        }
        return [];
    };
    /**
     * Checks if a given region has been bootstrapped with >= min version using CFN describeStacks with CDKToolKit.
     * @returns A Boolean that represents if region has been bootstrapped.
     */
    isBootstrapped = async () => {
        try {
            const { Stacks: stacks } = await this.cfnClient.send(new DescribeStacksCommand({
                StackName: CDK_BOOTSTRAP_STACK_NAME,
            }));
            const bootstrapVersion = stacks?.[0]?.Outputs?.find((output) => output.OutputKey === CDK_BOOTSTRAP_VERSION_KEY)?.OutputValue;
            if (!bootstrapVersion ||
                Number(bootstrapVersion) < CDK_MIN_BOOTSTRAP_VERSION) {
                return false;
            }
            return true;
        }
        catch (e) {
            if (e &&
                typeof e === 'object' &&
                'message' in e &&
                typeof e.message === 'string' &&
                e.message.includes('does not exist')) {
                return false;
            }
            // If we are unable to get the stack info due to other reasons(AccessDenied), we fail fast.
            throw e;
        }
    };
    /**
     * Generates a printable error message from the thrown error
     */
    getErrorMessage = (error) => {
        let message;
        if (error instanceof Error) {
            message = error.message;
            // Add the downstream exception
            if (error.cause && error.cause instanceof Error && error.cause.message) {
                message = `${message}\nCaused By: ${error.cause.message}\n`;
            }
            if (error instanceof AmplifyError && error.resolution) {
                message = `${message}\nResolution: ${error.resolution}\n`;
            }
        }
        else
            message = String(error);
        return message;
    };
    handleUnsupportedDestructiveChanges = async (options) => {
        this.printer.print(format.error('[Sandbox] We cannot deploy your new changes. You can either revert them or recreate your sandbox with the new changes (deleting all user data)'));
        // offer to recreate the sandbox with new properties
        const answer = await AmplifyPrompter.yesOrNo({
            message: 'Would you like to recreate your sandbox (deleting all user data)?',
            defaultValue: false,
        });
        if (answer) {
            await this.stop();
            await this.reset(options);
        }
        // else let the sandbox continue so customers can revert their changes
    };
    printSandboxNameInfo = async (sandboxIdentifier) => {
        const sandboxBackendId = await this.backendIdSandboxResolver(sandboxIdentifier);
        const stackName = BackendIdentifierConversions.toStackName(sandboxBackendId);
        this.printer.log(format.indent(format.highlight(format.bold('\nAmplify Sandbox\n'))));
        this.printer.log(format.indent(`${format.bold('Identifier:')} \t${sandboxBackendId.name}`));
        this.printer.log(format.indent(`${format.bold('Stack:')} \t${stackName}`));
        if (!sandboxIdentifier) {
            this.printer.log(`${format.indent(format.dim('\nTo specify a different sandbox identifier, use '))}${format.bold('--identifier')}`);
        }
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmlsZV93YXRjaGluZ19zYW5kYm94LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL2ZpbGVfd2F0Y2hpbmdfc2FuZGJveC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLFFBQVEsTUFBTSxrQkFBa0IsQ0FBQztBQUN4QyxPQUFPLGFBQTRCLE1BQU0saUJBQWlCLENBQUM7QUFTM0QsT0FBTyxjQUFjLE1BQU0saUJBQWlCLENBQUM7QUFDN0MsT0FBTyxJQUFJLE1BQU0sTUFBTSxDQUFDO0FBQ3hCLE9BQU8sRUFBRSxNQUFNLElBQUksQ0FBQztBQUNwQixPQUFPLEtBQUssTUFBTSxNQUFNLENBQUM7QUFDekIsK0RBQStEO0FBQy9ELGdFQUFnRTtBQUNoRSxPQUFPLFlBQVksTUFBTSxRQUFRLENBQUM7QUFDbEMsT0FBTyxFQUVMLHFCQUFxQixHQUN0QixNQUFNLGdDQUFnQyxDQUFDO0FBQ3hDLE9BQU8sRUFDTCxlQUFlLEVBQ2YsUUFBUSxFQUVSLE1BQU0sR0FDUCxNQUFNLHVCQUF1QixDQUFDO0FBQy9CLE9BQU8sRUFFTCx5QkFBeUIsR0FDMUIsTUFBTSw0QkFBNEIsQ0FBQztBQUNwQyxPQUFPLEVBQ0wsWUFBWSxFQUNaLGdCQUFnQixFQUNoQiw0QkFBNEIsR0FDN0IsTUFBTSw0QkFBNEIsQ0FBQztBQUVwQyxNQUFNLENBQUMsTUFBTSx3QkFBd0IsR0FBRyxZQUFZLENBQUM7QUFDckQsTUFBTSxDQUFDLE1BQU0seUJBQXlCLEdBQUcsa0JBQWtCLENBQUM7QUFDNUQsTUFBTSxDQUFDLE1BQU0seUJBQXlCLEdBQUcsQ0FBQyxDQUFDO0FBRTNDOzs7O0dBSUc7QUFDSCxNQUFNLENBQUMsTUFBTSxlQUFlLEdBQUcsQ0FBQyxNQUFjLEVBQUUsRUFBRSxDQUNoRCxXQUFXLE1BQU0sMkRBQTJELE1BQU0sRUFBRSxDQUFDO0FBRXZGOztHQUVHO0FBQ0gsTUFBTSxPQUFPLG1CQUFvQixTQUFRLFlBQVk7SUFTaEM7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQVpYLG1CQUFtQixDQUF3QztJQUMzRCw0QkFBNEIsR0FBRyxDQUFDLFVBQVUsQ0FBQyxDQUFDO0lBQzVDLG1CQUFtQixDQUFzQjtJQUVqRDs7T0FFRztJQUNILFlBQ21CLHdCQUFrRCxFQUNsRCxRQUFnQyxFQUNoQyxTQUErQixFQUMvQixPQUFnQixFQUNoQixPQUFPLEtBQUs7UUFFN0IsT0FBTyxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsR0FBRyxFQUFFLENBQUMsS0FBSyxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQztRQUMvQyxPQUFPLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxLQUFLLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDO1FBQ2hELEtBQUssRUFBRSxDQUFDO1FBUlMsNkJBQXdCLEdBQXhCLHdCQUF3QixDQUEwQjtRQUNsRCxhQUFRLEdBQVIsUUFBUSxDQUF3QjtRQUNoQyxjQUFTLEdBQVQsU0FBUyxDQUFzQjtRQUMvQixZQUFPLEdBQVAsT0FBTyxDQUFTO1FBQ2hCLFNBQUksR0FBSixJQUFJLENBQVE7SUFLL0IsQ0FBQztJQUVEOztPQUVHO0lBQ00sSUFBSSxDQUFDLFNBQXdCLEVBQUUsR0FBRyxJQUFlO1FBQ3hELE9BQU8sS0FBSyxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsR0FBRyxJQUFJLENBQUMsQ0FBQztJQUN4QyxDQUFDO0lBRUQ7O09BRUc7SUFDTSxFQUFFLENBQ1QsU0FBd0IsRUFDeEIsUUFBc0M7UUFFdEMsT0FBTyxLQUFLLENBQUMsRUFBRSxDQUFDLFNBQVMsRUFBRSxRQUFRLENBQUMsQ0FBQztJQUN2QyxDQUFDO0lBRUQ7O09BRUc7SUFDSCxLQUFLLEdBQUcsS0FBSyxFQUFFLE9BQXVCLEVBQUUsRUFBRTtRQUN4QyxNQUFNLFFBQVEsR0FBRyxPQUFPLENBQUMsR0FBRyxJQUFJLFdBQVcsQ0FBQztRQUM1QyxNQUFNLGVBQWUsR0FBRyxPQUFPLENBQUMsZUFBZSxJQUFJLElBQUksQ0FBQztRQUV4RCxJQUFJLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsRUFBRTtZQUM1QixNQUFNLElBQUksZ0JBQWdCLENBQUMsbUJBQW1CLEVBQUU7Z0JBQzlDLE9BQU8sRUFBRSxHQUFHLFFBQVEsa0JBQWtCO2dCQUN0QyxVQUFVLEVBQ1IsMEVBQTBFO2FBQzdFLENBQUMsQ0FBQztTQUNKO1FBRUQsSUFBSSxDQUFDLG1CQUFtQixHQUFHLE1BQU0seUJBQXlCLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDckUsTUFBTSxZQUFZLEdBQUcsTUFBTSxJQUFJLENBQUMsY0FBYyxFQUFFLENBQUM7UUFDakQsSUFBSSxDQUFDLFlBQVksRUFBRTtZQUNqQixJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FDZCxxSkFBcUosQ0FDdEosQ0FBQztZQUNGLDJDQUEyQztZQUMzQyxNQUFNLE1BQU0sR0FBRyxNQUFNLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRSxDQUFDO1lBQ3BELE1BQU0sSUFBSSxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztZQUN6QyxPQUFPO1NBQ1I7UUFFRCxNQUFNLFlBQVksR0FBRyxJQUFJLENBQUMsa0JBQWtCLEVBQUUsQ0FBQztRQUMvQyxJQUFJLENBQUMsNEJBQTRCO1lBQy9CLElBQUksQ0FBQyw0QkFBNEIsQ0FBQyxNQUFNLENBQUMsR0FBRyxZQUFZLENBQUMsQ0FBQztRQUU1RCxNQUFNLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLENBQUM7UUFFcEQsMkVBQTJFO1FBQzNFLHVEQUF1RDtRQUN2RCxpRkFBaUY7UUFDakYsdUZBQXVGO1FBQ3ZGLDJEQUEyRDtRQUMzRCxrREFBa0Q7UUFFbEQsK0ZBQStGO1FBQy9GLGlHQUFpRztRQUNqRyxpR0FBaUc7UUFDakcsaUdBQWlHO1FBQ2pHLGlGQUFpRjtRQUVqRixJQUFJLEtBQUssR0FBb0MsTUFBTSxDQUFDO1FBRXBELE1BQU0sY0FBYyxHQUFHLFFBQVEsQ0FBQyxLQUFLLElBQUksRUFBRTtZQUN6QyxLQUFLLEdBQUcsV0FBVyxDQUFDO1lBQ3BCLE1BQU0sSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUUzQixnRUFBZ0U7WUFDaEUsMkRBQTJEO1lBQzNELE9BQVEsS0FBZ0MsS0FBSyxRQUFRLEVBQUU7Z0JBQ3JELDBFQUEwRTtnQkFDMUUsNEVBQTRFO2dCQUM1RSxLQUFLLEdBQUcsV0FBVyxDQUFDO2dCQUNwQixJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FDZCxxR0FBcUcsQ0FDdEcsQ0FBQztnQkFDRixNQUFNLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7YUFDNUI7WUFDRCxLQUFLLEdBQUcsTUFBTSxDQUFDO1lBQ2YsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDO1FBQ3RCLENBQUMsQ0FBQyxDQUFDO1FBRUgsSUFBSSxlQUFlLEVBQUU7WUFDbkIsSUFBSSxDQUFDLG1CQUFtQixHQUFHLE1BQU0sYUFBYSxDQUFDLFNBQVMsQ0FDdEQsUUFBUSxFQUNSLEtBQUssRUFBRSxDQUFDLEVBQUUsTUFBTSxFQUFFLEVBQUU7Z0JBQ2xCLDhCQUE4QjtnQkFDOUIsTUFBTSxPQUFPLENBQUMsR0FBRyxDQUNmLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUUsSUFBSSxFQUFFLEVBQUUsRUFBRTtvQkFDdkMsSUFBSSxDQUFDLG1CQUFtQixDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsQ0FBQztvQkFDL0MsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQ2QscUNBQXFDLFNBQVMsV0FBVyxJQUFJLEVBQUUsQ0FDaEUsQ0FBQztnQkFDSixDQUFDLENBQUMsQ0FDSCxDQUFDO2dCQUNGLElBQUksS0FBSyxLQUFLLE1BQU0sRUFBRTtvQkFDcEIsTUFBTSxjQUFjLEVBQUUsQ0FBQztpQkFDeEI7cUJBQU07b0JBQ0wscURBQXFEO29CQUNyRCxLQUFLLEdBQUcsUUFBUSxDQUFDO29CQUNqQixJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FDZCxzREFBc0Q7d0JBQ3BELDJEQUEyRCxDQUM5RCxDQUFDO2lCQUNIO1lBQ0gsQ0FBQyxFQUNEO2dCQUNFLE1BQU0sRUFBRSxJQUFJLENBQUMsNEJBQTRCLENBQUMsTUFBTSxDQUM5QyxHQUFHLENBQUMsT0FBTyxDQUFDLE9BQU8sSUFBSSxFQUFFLENBQUMsQ0FDM0I7YUFDRixDQUNGLENBQUM7WUFDRixvRUFBb0U7WUFDcEUsTUFBTSxjQUFjLEVBQUUsQ0FBQztTQUN4QjthQUFNO1lBQ0wsTUFBTSxJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1NBQzVCO0lBQ0gsQ0FBQyxDQUFDO0lBRUY7O09BRUc7SUFDSCxJQUFJLEdBQUcsS0FBSyxJQUFJLEVBQUU7UUFDaEIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMseUJBQXlCLEVBQUUsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQzVELHdEQUF3RDtRQUN4RCxNQUFNLElBQUksQ0FBQyxtQkFBbUIsRUFBRSxXQUFXLEVBQUUsQ0FBQztJQUNoRCxDQUFDLENBQUM7SUFFRjs7T0FFRztJQUNILE1BQU0sR0FBRyxLQUFLLEVBQUUsT0FBNkIsRUFBRSxFQUFFO1FBQy9DLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUNkLG9FQUFvRSxDQUNyRSxDQUFDO1FBQ0YsTUFBTSxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FDekIsTUFBTSxJQUFJLENBQUMsd0JBQXdCLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxDQUN4RCxDQUFDO1FBQ0YsSUFBSSxDQUFDLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDO1FBQ2hDLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLDhCQUE4QixDQUFDLENBQUM7SUFDbkQsQ0FBQyxDQUFDO0lBRU0sd0JBQXdCLEdBQUcsR0FBWSxFQUFFO1FBQy9DLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxtQkFBbUIsRUFBRSxDQUFDO1FBQ2hFLDBEQUEwRDtRQUMxRCxNQUFNLHlCQUF5QixHQUM3QixRQUFRLENBQUMseUJBQXlCO1lBQ2xDLENBQUMsUUFBUSxDQUFDLDBCQUEwQixDQUFDO1FBQ3ZDLE9BQU8sQ0FDTCx5QkFBeUI7WUFDekIsUUFBUSxDQUFDLDJDQUEyQyxDQUNyRCxDQUFDO0lBQ0osQ0FBQyxDQUFDO0lBRU0sTUFBTSxHQUFHLEtBQUssRUFBRSxPQUF1QixFQUFFLEVBQUU7UUFDakQsSUFBSTtZQUNGLE1BQU0sWUFBWSxHQUFHLE1BQU0sSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQzdDLE1BQU0sSUFBSSxDQUFDLHdCQUF3QixDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUM7WUFDdkQsZ0VBQWdFO1lBQ2hFLGdDQUFnQztZQUNoQyxJQUFJLENBQUMsd0JBQXdCLENBQzlCLENBQUM7WUFDRixJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxpQ0FBaUMsRUFBRSxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDcEUsSUFBSSxDQUFDLElBQUksQ0FBQyxzQkFBc0IsRUFBRSxZQUFZLENBQUMsQ0FBQztTQUNqRDtRQUFDLE9BQU8sS0FBSyxFQUFFO1lBQ2QsNkJBQTZCO1lBQzdCLElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDOUQsSUFBSSxDQUFDLElBQUksQ0FBQyxrQkFBa0IsRUFBRSxLQUFLLENBQUMsQ0FBQztZQUVyQyxzRUFBc0U7WUFDdEUseUlBQXlJO1lBQ3pJLHFEQUFxRDtZQUNyRCxJQUNFLEtBQUssWUFBWSxZQUFZO2dCQUM3QixLQUFLLENBQUMsSUFBSSxLQUFLLDRCQUE0QixFQUMzQztnQkFDQSxNQUFNLElBQUksQ0FBQyxtQ0FBbUMsQ0FBQyxPQUFPLENBQUMsQ0FBQzthQUN6RDtZQUNELDREQUE0RDtTQUM3RDtJQUNILENBQUMsQ0FBQztJQUVNLEtBQUssR0FBRyxLQUFLLEVBQUUsT0FBdUIsRUFBRSxFQUFFO1FBQ2hELE1BQU0sSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLFVBQVUsRUFBRSxPQUFPLENBQUMsVUFBVSxFQUFFLENBQUMsQ0FBQztRQUN0RCxNQUFNLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDNUIsQ0FBQyxDQUFDO0lBRUY7O09BRUc7SUFDSyxZQUFZLEdBQUcsR0FBRyxFQUFFO1FBQzFCLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLHdDQUF3QyxDQUFDLENBQUM7SUFDN0QsQ0FBQyxDQUFDO0lBRUY7O09BRUc7SUFDSyxrQkFBa0IsR0FBRyxHQUFHLEVBQUU7UUFDaEMsTUFBTSxpQkFBaUIsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLEVBQUUsRUFBRSxZQUFZLENBQUMsQ0FBQztRQUNqRSxJQUFJLEVBQUUsQ0FBQyxVQUFVLENBQUMsaUJBQWlCLENBQUMsRUFBRTtZQUNwQyxPQUFPLGNBQWM7aUJBQ2xCLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQztpQkFDeEIsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLE9BQWUsRUFBRSxFQUFFLENBQ2hDLE9BQU8sQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FDekQ7aUJBQ0EsTUFBTSxDQUFDLENBQUMsT0FBZSxFQUFFLEVBQUU7Z0JBQzFCLElBQUksT0FBTyxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsRUFBRTtvQkFDM0IsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQ2QscUJBQXFCLE9BQU8sMEJBQTBCLE9BQU8sQ0FBQyxTQUFTLENBQ3JFLENBQUMsQ0FDRix5RUFBeUUsQ0FDM0UsQ0FBQztvQkFDRixPQUFPLEtBQUssQ0FBQztpQkFDZDtnQkFDRCxPQUFPLElBQUksQ0FBQztZQUNkLENBQUMsQ0FBQyxDQUFDO1NBQ047UUFDRCxPQUFPLEVBQUUsQ0FBQztJQUNaLENBQUMsQ0FBQztJQUVGOzs7T0FHRztJQUNLLGNBQWMsR0FBRyxLQUFLLElBQUksRUFBRTtRQUNsQyxJQUFJO1lBQ0YsTUFBTSxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsR0FBRyxNQUFNLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUNsRCxJQUFJLHFCQUFxQixDQUFDO2dCQUN4QixTQUFTLEVBQUUsd0JBQXdCO2FBQ3BDLENBQUMsQ0FDSCxDQUFDO1lBQ0YsTUFBTSxnQkFBZ0IsR0FBRyxNQUFNLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxPQUFPLEVBQUUsSUFBSSxDQUNqRCxDQUFDLE1BQU0sRUFBRSxFQUFFLENBQUMsTUFBTSxDQUFDLFNBQVMsS0FBSyx5QkFBeUIsQ0FDM0QsRUFBRSxXQUFXLENBQUM7WUFDZixJQUNFLENBQUMsZ0JBQWdCO2dCQUNqQixNQUFNLENBQUMsZ0JBQWdCLENBQUMsR0FBRyx5QkFBeUIsRUFDcEQ7Z0JBQ0EsT0FBTyxLQUFLLENBQUM7YUFDZDtZQUNELE9BQU8sSUFBSSxDQUFDO1NBQ2I7UUFBQyxPQUFPLENBQUMsRUFBRTtZQUNWLElBQ0UsQ0FBQztnQkFDRCxPQUFPLENBQUMsS0FBSyxRQUFRO2dCQUNyQixTQUFTLElBQUksQ0FBQztnQkFDZCxPQUFPLENBQUMsQ0FBQyxPQUFPLEtBQUssUUFBUTtnQkFDN0IsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsZ0JBQWdCLENBQUMsRUFDcEM7Z0JBQ0EsT0FBTyxLQUFLLENBQUM7YUFDZDtZQUNELDJGQUEyRjtZQUMzRixNQUFNLENBQUMsQ0FBQztTQUNUO0lBQ0gsQ0FBQyxDQUFDO0lBRUY7O09BRUc7SUFDSyxlQUFlLEdBQUcsQ0FBQyxLQUFjLEVBQUUsRUFBRTtRQUMzQyxJQUFJLE9BQU8sQ0FBQztRQUNaLElBQUksS0FBSyxZQUFZLEtBQUssRUFBRTtZQUMxQixPQUFPLEdBQUcsS0FBSyxDQUFDLE9BQU8sQ0FBQztZQUV4QiwrQkFBK0I7WUFDL0IsSUFBSSxLQUFLLENBQUMsS0FBSyxJQUFJLEtBQUssQ0FBQyxLQUFLLFlBQVksS0FBSyxJQUFJLEtBQUssQ0FBQyxLQUFLLENBQUMsT0FBTyxFQUFFO2dCQUN0RSxPQUFPLEdBQUcsR0FBRyxPQUFPLGdCQUFnQixLQUFLLENBQUMsS0FBSyxDQUFDLE9BQU8sSUFBSSxDQUFDO2FBQzdEO1lBRUQsSUFBSSxLQUFLLFlBQVksWUFBWSxJQUFJLEtBQUssQ0FBQyxVQUFVLEVBQUU7Z0JBQ3JELE9BQU8sR0FBRyxHQUFHLE9BQU8saUJBQWlCLEtBQUssQ0FBQyxVQUFVLElBQUksQ0FBQzthQUMzRDtTQUNGOztZQUFNLE9BQU8sR0FBRyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDL0IsT0FBTyxPQUFPLENBQUM7SUFDakIsQ0FBQyxDQUFDO0lBRU0sbUNBQW1DLEdBQUcsS0FBSyxFQUNqRCxPQUF1QixFQUN2QixFQUFFO1FBQ0YsSUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQ2hCLE1BQU0sQ0FBQyxLQUFLLENBQ1YsZ0pBQWdKLENBQ2pKLENBQ0YsQ0FBQztRQUNGLG9EQUFvRDtRQUNwRCxNQUFNLE1BQU0sR0FBRyxNQUFNLGVBQWUsQ0FBQyxPQUFPLENBQUM7WUFDM0MsT0FBTyxFQUNMLG1FQUFtRTtZQUNyRSxZQUFZLEVBQUUsS0FBSztTQUNwQixDQUFDLENBQUM7UUFDSCxJQUFJLE1BQU0sRUFBRTtZQUNWLE1BQU0sSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO1lBQ2xCLE1BQU0sSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQztTQUMzQjtRQUNELHNFQUFzRTtJQUN4RSxDQUFDLENBQUM7SUFFTSxvQkFBb0IsR0FBRyxLQUFLLEVBQUUsaUJBQTBCLEVBQUUsRUFBRTtRQUNsRSxNQUFNLGdCQUFnQixHQUFHLE1BQU0sSUFBSSxDQUFDLHdCQUF3QixDQUMxRCxpQkFBaUIsQ0FDbEIsQ0FBQztRQUNGLE1BQU0sU0FBUyxHQUNiLDRCQUE0QixDQUFDLFdBQVcsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO1FBQzdELElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUNkLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLHFCQUFxQixDQUFDLENBQUMsQ0FBQyxDQUNwRSxDQUFDO1FBQ0YsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQ2QsTUFBTSxDQUFDLE1BQU0sQ0FBQyxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLE1BQU0sZ0JBQWdCLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FDMUUsQ0FBQztRQUNGLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLFNBQVMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUMzRSxJQUFJLENBQUMsaUJBQWlCLEVBQUU7WUFDdEIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQ2QsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUNkLE1BQU0sQ0FBQyxHQUFHLENBQUMsbURBQW1ELENBQUMsQ0FDaEUsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxFQUFFLENBQ2xDLENBQUM7U0FDSDtJQUNILENBQUMsQ0FBQztDQUNIIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGRlYm91bmNlIGZyb20gJ2RlYm91bmNlLXByb21pc2UnO1xuaW1wb3J0IHBhcmNlbFdhdGNoZXIsIHsgc3Vic2NyaWJlIH0gZnJvbSAnQHBhcmNlbC93YXRjaGVyJztcbmltcG9ydCB7IEFtcGxpZnlTYW5kYm94RXhlY3V0b3IgfSBmcm9tICcuL3NhbmRib3hfZXhlY3V0b3IuanMnO1xuaW1wb3J0IHtcbiAgQmFja2VuZElkU2FuZGJveFJlc29sdmVyLFxuICBTYW5kYm94LFxuICBTYW5kYm94RGVsZXRlT3B0aW9ucyxcbiAgU2FuZGJveEV2ZW50cyxcbiAgU2FuZGJveE9wdGlvbnMsXG59IGZyb20gJy4vc2FuZGJveC5qcyc7XG5pbXBvcnQgcGFyc2VHaXRJZ25vcmUgZnJvbSAncGFyc2UtZ2l0aWdub3JlJztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IGZzIGZyb20gJ2ZzJztcbmltcG9ydCBfb3BlbiBmcm9tICdvcGVuJztcbi8vIEV2ZW50RW1pdHRlciBpcyBhIGNsYXNzIG5hbWUgYW5kIGV4cGVjdGVkIHRvIGhhdmUgUGFzY2FsQ2FzZVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICdldmVudHMnO1xuaW1wb3J0IHtcbiAgQ2xvdWRGb3JtYXRpb25DbGllbnQsXG4gIERlc2NyaWJlU3RhY2tzQ29tbWFuZCxcbn0gZnJvbSAnQGF3cy1zZGsvY2xpZW50LWNsb3VkZm9ybWF0aW9uJztcbmltcG9ydCB7XG4gIEFtcGxpZnlQcm9tcHRlcixcbiAgTG9nTGV2ZWwsXG4gIFByaW50ZXIsXG4gIGZvcm1hdCxcbn0gZnJvbSAnQGF3cy1hbXBsaWZ5L2NsaS1jb3JlJztcbmltcG9ydCB7XG4gIEZpbGVzQ2hhbmdlc1RyYWNrZXIsXG4gIGNyZWF0ZUZpbGVzQ2hhbmdlc1RyYWNrZXIsXG59IGZyb20gJy4vZmlsZXNfY2hhbmdlc190cmFja2VyLmpzJztcbmltcG9ydCB7XG4gIEFtcGxpZnlFcnJvcixcbiAgQW1wbGlmeVVzZXJFcnJvcixcbiAgQmFja2VuZElkZW50aWZpZXJDb252ZXJzaW9ucyxcbn0gZnJvbSAnQGF3cy1hbXBsaWZ5L3BsYXRmb3JtLWNvcmUnO1xuXG5leHBvcnQgY29uc3QgQ0RLX0JPT1RTVFJBUF9TVEFDS19OQU1FID0gJ0NES1Rvb2xraXQnO1xuZXhwb3J0IGNvbnN0IENES19CT09UU1RSQVBfVkVSU0lPTl9LRVkgPSAnQm9vdHN0cmFwVmVyc2lvbic7XG5leHBvcnQgY29uc3QgQ0RLX01JTl9CT09UU1RSQVBfVkVSU0lPTiA9IDY7XG5cbi8qKlxuICogQ29uc3RydWN0cyBBbXBsaWZ5IENvbnNvbGUgYm9vdHN0cmFwIFVSTCBmb3IgYSBnaXZlbiByZWdpb25cbiAqIEBwYXJhbSByZWdpb24gQVdTIHJlZ2lvblxuICogQHJldHVybnMgQW1wbGlmeSBDb25zb2xlIGJvb3RzdHJhcCBVUkxcbiAqL1xuZXhwb3J0IGNvbnN0IGdldEJvb3RzdHJhcFVybCA9IChyZWdpb246IHN0cmluZykgPT5cbiAgYGh0dHBzOi8vJHtyZWdpb259LmNvbnNvbGUuYXdzLmFtYXpvbi5jb20vYW1wbGlmeS9jcmVhdGUvYm9vdHN0cmFwP3JlZ2lvbj0ke3JlZ2lvbn1gO1xuXG4vKipcbiAqIFJ1bnMgYSBmaWxlIHdhdGNoZXIgYW5kIGRlcGxveXNcbiAqL1xuZXhwb3J0IGNsYXNzIEZpbGVXYXRjaGluZ1NhbmRib3ggZXh0ZW5kcyBFdmVudEVtaXR0ZXIgaW1wbGVtZW50cyBTYW5kYm94IHtcbiAgcHJpdmF0ZSB3YXRjaGVyU3Vic2NyaXB0aW9uOiBBd2FpdGVkPFJldHVyblR5cGU8dHlwZW9mIHN1YnNjcmliZT4+O1xuICBwcml2YXRlIG91dHB1dEZpbGVzRXhjbHVkZWRGcm9tV2F0Y2ggPSBbJy5hbXBsaWZ5J107XG4gIHByaXZhdGUgZmlsZXNDaGFuZ2VzVHJhY2tlcjogRmlsZXNDaGFuZ2VzVHJhY2tlcjtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHdhdGNoZXIgcHJvY2VzcyBmb3IgdGhpcyBpbnN0YW5jZVxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSBiYWNrZW5kSWRTYW5kYm94UmVzb2x2ZXI6IEJhY2tlbmRJZFNhbmRib3hSZXNvbHZlcixcbiAgICBwcml2YXRlIHJlYWRvbmx5IGV4ZWN1dG9yOiBBbXBsaWZ5U2FuZGJveEV4ZWN1dG9yLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgY2ZuQ2xpZW50OiBDbG91ZEZvcm1hdGlvbkNsaWVudCxcbiAgICBwcml2YXRlIHJlYWRvbmx5IHByaW50ZXI6IFByaW50ZXIsXG4gICAgcHJpdmF0ZSByZWFkb25seSBvcGVuID0gX29wZW5cbiAgKSB7XG4gICAgcHJvY2Vzcy5vbmNlKCdTSUdJTlQnLCAoKSA9PiB2b2lkIHRoaXMuc3RvcCgpKTtcbiAgICBwcm9jZXNzLm9uY2UoJ1NJR1RFUk0nLCAoKSA9PiB2b2lkIHRoaXMuc3RvcCgpKTtcbiAgICBzdXBlcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0ZG9jXG4gICAqL1xuICBvdmVycmlkZSBlbWl0KGV2ZW50TmFtZTogU2FuZGJveEV2ZW50cywgLi4uYXJnczogdW5rbm93bltdKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHN1cGVyLmVtaXQoZXZlbnROYW1lLCAuLi5hcmdzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdGRvY1xuICAgKi9cbiAgb3ZlcnJpZGUgb24oXG4gICAgZXZlbnROYW1lOiBTYW5kYm94RXZlbnRzLFxuICAgIGxpc3RlbmVyOiAoLi4uYXJnczogdW5rbm93bltdKSA9PiB2b2lkXG4gICk6IHRoaXMge1xuICAgIHJldHVybiBzdXBlci5vbihldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdGRvY1xuICAgKi9cbiAgc3RhcnQgPSBhc3luYyAob3B0aW9uczogU2FuZGJveE9wdGlvbnMpID0+IHtcbiAgICBjb25zdCB3YXRjaERpciA9IG9wdGlvbnMuZGlyID8/ICcuL2FtcGxpZnknO1xuICAgIGNvbnN0IHdhdGNoRm9yQ2hhbmdlcyA9IG9wdGlvbnMud2F0Y2hGb3JDaGFuZ2VzID8/IHRydWU7XG5cbiAgICBpZiAoIWZzLmV4aXN0c1N5bmMod2F0Y2hEaXIpKSB7XG4gICAgICB0aHJvdyBuZXcgQW1wbGlmeVVzZXJFcnJvcignUGF0aE5vdEZvdW5kRXJyb3InLCB7XG4gICAgICAgIG1lc3NhZ2U6IGAke3dhdGNoRGlyfSBkb2VzIG5vdCBleGlzdC5gLFxuICAgICAgICByZXNvbHV0aW9uOlxuICAgICAgICAgICdNYWtlIHN1cmUgeW91IGFyZSBydW5uaW5nIHRoaXMgY29tbWFuZCBmcm9tIHlvdXIgcHJvamVjdCByb290IGRpcmVjdG9yeS4nLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5maWxlc0NoYW5nZXNUcmFja2VyID0gYXdhaXQgY3JlYXRlRmlsZXNDaGFuZ2VzVHJhY2tlcih3YXRjaERpcik7XG4gICAgY29uc3QgYm9vdHN0cmFwcGVkID0gYXdhaXQgdGhpcy5pc0Jvb3RzdHJhcHBlZCgpO1xuICAgIGlmICghYm9vdHN0cmFwcGVkKSB7XG4gICAgICB0aGlzLnByaW50ZXIubG9nKFxuICAgICAgICAnVGhlIGdpdmVuIHJlZ2lvbiBoYXMgbm90IGJlZW4gYm9vdHN0cmFwcGVkLiBTaWduIGluIHRvIGNvbnNvbGUgYXMgYSBSb290IHVzZXIgb3IgQWRtaW4gdG8gY29tcGxldGUgdGhlIGJvb3RzdHJhcCBwcm9jZXNzLCB0aGVuIHJlc3RhcnQgdGhlIHNhbmRib3guJ1xuICAgICAgKTtcbiAgICAgIC8vIGdldCByZWdpb24gZnJvbSBhbiBhdmFpbGFibGUgc2RrIGNsaWVudDtcbiAgICAgIGNvbnN0IHJlZ2lvbiA9IGF3YWl0IHRoaXMuY2ZuQ2xpZW50LmNvbmZpZy5yZWdpb24oKTtcbiAgICAgIGF3YWl0IHRoaXMub3BlbihnZXRCb290c3RyYXBVcmwocmVnaW9uKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgaWdub3JlZFBhdGhzID0gdGhpcy5nZXRHaXRJZ25vcmVkUGF0aHMoKTtcbiAgICB0aGlzLm91dHB1dEZpbGVzRXhjbHVkZWRGcm9tV2F0Y2ggPVxuICAgICAgdGhpcy5vdXRwdXRGaWxlc0V4Y2x1ZGVkRnJvbVdhdGNoLmNvbmNhdCguLi5pZ25vcmVkUGF0aHMpO1xuXG4gICAgYXdhaXQgdGhpcy5wcmludFNhbmRib3hOYW1lSW5mbyhvcHRpb25zLmlkZW50aWZpZXIpO1xuXG4gICAgLy8gU2luY2UgJ2NkayBkZXBsb3knIGlzIGEgcmVsYXRpdmVseSBzbG93IG9wZXJhdGlvbiBmb3IgYSAnd2F0Y2gnIHByb2Nlc3MsXG4gICAgLy8gaW50cm9kdWNlIGEgY29uY3VycmVuY3kgbGF0Y2ggdGhhdCB0cmFja3MgdGhlIHN0YXRlLlxuICAgIC8vIFRoaXMgd2F5LCBpZiBmaWxlIGNoYW5nZSBldmVudHMgYXJyaXZlIHdoZW4gYSAnY2RrIGRlcGxveScgaXMgc3RpbGwgZXhlY3V0aW5nLFxuICAgIC8vIHdlIHdpbGwgYmF0Y2ggdGhlbSwgYW5kIHRyaWdnZXIgYW5vdGhlciAnY2RrIGRlcGxveScgYWZ0ZXIgdGhlIGN1cnJlbnQgb25lIGZpbmlzaGVzLFxuICAgIC8vIG1ha2luZyBzdXJlICdjZGsgZGVwbG95J3MgIGFsd2F5cyBleGVjdXRlIG9uZSBhdCBhIHRpbWUuXG4gICAgLy8gSGVyZSdzIGEgZGlhZ3JhbSBzaG93aW5nIHRoZSBzdGF0ZSB0cmFuc2l0aW9uczpcblxuICAgIC8vIC0tLS0tLS0tICAgIGZpbGUgY2hhbmdlZCAgICAgLS0tLS0tLS0tLS0tLS0gICAgZmlsZSBjaGFuZ2VkICAgICAtLS0tLS0tLS0tLS0tLSAgZmlsZSBjaGFuZ2VkXG4gICAgLy8gfCAgICAgIHwgLS0tLS0tLS0tLS0tLS0tLS0tPiB8ICAgICAgICAgICAgfCAtLS0tLS0tLS0tLS0tLS0tLS0+IHwgICAgICAgICAgICB8IC0tLS0tLS0tLS0tLS0tfFxuICAgIC8vIHwgb3BlbiB8ICAgICAgICAgICAgICAgICAgICAgfCBkZXBsb3lpbmcgIHwgICAgICAgICAgICAgICAgICAgICB8ICAgcXVldWVkICAgfCAgICAgICAgICAgICAgIHxcbiAgICAvLyB8ICAgICAgfCA8LS0tLS0tLS0tLS0tLS0tLS0tIHwgICAgICAgICAgICB8IDwtLS0tLS0tLS0tLS0tLS0tLS0gfCAgICAgICAgICAgIHwgPC0tLS0tLS0tLS0tLS18XG4gICAgLy8gLS0tLS0tLS0gICdjZGsgZGVwbG95JyBkb25lICAtLS0tLS0tLS0tLS0tLSAgJ2NkayBkZXBsb3knIGRvbmUgIC0tLS0tLS0tLS0tLS0tXG5cbiAgICBsZXQgbGF0Y2g6ICdvcGVuJyB8ICdkZXBsb3lpbmcnIHwgJ3F1ZXVlZCcgPSAnb3Blbic7XG5cbiAgICBjb25zdCBkZXBsb3lBbmRXYXRjaCA9IGRlYm91bmNlKGFzeW5jICgpID0+IHtcbiAgICAgIGxhdGNoID0gJ2RlcGxveWluZyc7XG4gICAgICBhd2FpdCB0aGlzLmRlcGxveShvcHRpb25zKTtcblxuICAgICAgLy8gSWYgbGF0Y2ggaXMgc3RpbGwgJ2RlcGxveWluZycgYWZ0ZXIgdGhlICdhd2FpdCcsIHRoYXQncyBmaW5lLFxuICAgICAgLy8gYnV0IGlmIGl0J3MgJ3F1ZXVlZCcsIHRoYXQgbWVhbnMgd2UgbmVlZCB0byBkZXBsb3kgYWdhaW5cbiAgICAgIHdoaWxlICgobGF0Y2ggYXMgJ2RlcGxveWluZycgfCAncXVldWVkJykgPT09ICdxdWV1ZWQnKSB7XG4gICAgICAgIC8vIFR5cGVTY3JpcHQgZG9lc24ndCByZWFsaXplIGxhdGNoIGNhbiBjaGFuZ2UgYmV0d2VlbiAnYXdhaXRzJyDCr1xcXyjjg4QpXy/CryxcbiAgICAgICAgLy8gYW5kIHRoaW5rcyB0aGUgYWJvdmUgJ3doaWxlJyBjb25kaXRpb24gaXMgYWx3YXlzICdmYWxzZScgd2l0aG91dCB0aGUgY2FzdFxuICAgICAgICBsYXRjaCA9ICdkZXBsb3lpbmcnO1xuICAgICAgICB0aGlzLnByaW50ZXIubG9nKFxuICAgICAgICAgIFwiW1NhbmRib3hdIERldGVjdGVkIGZpbGUgY2hhbmdlcyB3aGlsZSBwcmV2aW91cyBkZXBsb3ltZW50IHdhcyBpbiBwcm9ncmVzcy4gSW52b2tpbmcgJ3NhbmRib3gnIGFnYWluXCJcbiAgICAgICAgKTtcbiAgICAgICAgYXdhaXQgdGhpcy5kZXBsb3kob3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBsYXRjaCA9ICdvcGVuJztcbiAgICAgIHRoaXMuZW1pdFdhdGNoaW5nKCk7XG4gICAgfSk7XG5cbiAgICBpZiAod2F0Y2hGb3JDaGFuZ2VzKSB7XG4gICAgICB0aGlzLndhdGNoZXJTdWJzY3JpcHRpb24gPSBhd2FpdCBwYXJjZWxXYXRjaGVyLnN1YnNjcmliZShcbiAgICAgICAgd2F0Y2hEaXIsXG4gICAgICAgIGFzeW5jIChfLCBldmVudHMpID0+IHtcbiAgICAgICAgICAvLyBMb2cgYW5kIHRyYWNrIGZpbGUgY2hhbmdlcy5cbiAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgICAgIGV2ZW50cy5tYXAoKHsgdHlwZTogZXZlbnROYW1lLCBwYXRoIH0pID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5maWxlc0NoYW5nZXNUcmFja2VyLnRyYWNrRmlsZUNoYW5nZShwYXRoKTtcbiAgICAgICAgICAgICAgdGhpcy5wcmludGVyLmxvZyhcbiAgICAgICAgICAgICAgICBgW1NhbmRib3hdIFRyaWdnZXJlZCBkdWUgdG8gYSBmaWxlICR7ZXZlbnROYW1lfSBldmVudDogJHtwYXRofWBcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAobGF0Y2ggPT09ICdvcGVuJykge1xuICAgICAgICAgICAgYXdhaXQgZGVwbG95QW5kV2F0Y2goKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdGhpcyBtZWFucyBsYXRjaCBpcyBlaXRoZXIgJ2RlcGxveWluZycgb3IgJ3F1ZXVlZCdcbiAgICAgICAgICAgIGxhdGNoID0gJ3F1ZXVlZCc7XG4gICAgICAgICAgICB0aGlzLnByaW50ZXIubG9nKFxuICAgICAgICAgICAgICAnW1NhbmRib3hdIFByZXZpb3VzIGRlcGxveW1lbnQgaXMgc3RpbGwgaW4gcHJvZ3Jlc3MuICcgK1xuICAgICAgICAgICAgICAgICdXaWxsIHF1ZXVlIGZvciBhbm90aGVyIGRlcGxveW1lbnQgYWZ0ZXIgdGhpcyBvbmUgZmluaXNoZXMnXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGlnbm9yZTogdGhpcy5vdXRwdXRGaWxlc0V4Y2x1ZGVkRnJvbVdhdGNoLmNvbmNhdChcbiAgICAgICAgICAgIC4uLihvcHRpb25zLmV4Y2x1ZGUgPz8gW10pXG4gICAgICAgICAgKSxcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIC8vIFN0YXJ0IHRoZSBmaXJzdCBmdWxsIGRlcGxveW1lbnQgd2l0aG91dCB3YWl0aW5nIGZvciBhIGZpbGUgY2hhbmdlXG4gICAgICBhd2FpdCBkZXBsb3lBbmRXYXRjaCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhd2FpdCB0aGlzLmRlcGxveShvcHRpb25zKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0ZG9jXG4gICAqL1xuICBzdG9wID0gYXN5bmMgKCkgPT4ge1xuICAgIHRoaXMucHJpbnRlci5sb2coYFtTYW5kYm94XSBTaHV0dGluZyBkb3duYCwgTG9nTGV2ZWwuREVCVUcpO1xuICAgIC8vIGNhbiBiZSB1bmRlZmluZWQgaWYgY29tbWFuZCBleGl0cyBiZWZvcmUgc3Vic2NyaXB0aW9uXG4gICAgYXdhaXQgdGhpcy53YXRjaGVyU3Vic2NyaXB0aW9uPy51bnN1YnNjcmliZSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdGRvY1xuICAgKi9cbiAgZGVsZXRlID0gYXN5bmMgKG9wdGlvbnM6IFNhbmRib3hEZWxldGVPcHRpb25zKSA9PiB7XG4gICAgdGhpcy5wcmludGVyLmxvZyhcbiAgICAgICdbU2FuZGJveF0gRGVsZXRpbmcgYWxsIHRoZSByZXNvdXJjZXMgaW4gdGhlIHNhbmRib3ggZW52aXJvbm1lbnQuLi4nXG4gICAgKTtcbiAgICBhd2FpdCB0aGlzLmV4ZWN1dG9yLmRlc3Ryb3koXG4gICAgICBhd2FpdCB0aGlzLmJhY2tlbmRJZFNhbmRib3hSZXNvbHZlcihvcHRpb25zLmlkZW50aWZpZXIpXG4gICAgKTtcbiAgICB0aGlzLmVtaXQoJ3N1Y2Nlc3NmdWxEZWxldGlvbicpO1xuICAgIHRoaXMucHJpbnRlci5sb2coJ1tTYW5kYm94XSBGaW5pc2hlZCBkZWxldGluZy4nKTtcbiAgfTtcblxuICBwcml2YXRlIHNob3VsZFZhbGlkYXRlQXBwU291cmNlcyA9ICgpOiBib29sZWFuID0+IHtcbiAgICBjb25zdCBzbmFwc2hvdCA9IHRoaXMuZmlsZXNDaGFuZ2VzVHJhY2tlci5nZXRBbmRSZXNldFNuYXBzaG90KCk7XG4gICAgLy8gaWYgemVybyBmaWxlcyBjaGFuZ2VkIHRoaXMgaW5kaWNhdGVzIGluaXRpYWwgZGVwbG95bWVudFxuICAgIGNvbnN0IHNob3VsZFZhbGlkYXRlT25Db2xkU3RhcnQgPVxuICAgICAgc25hcHNob3QuaGFkVHlwZVNjcmlwdEZpbGVzQXRTdGFydCAmJlxuICAgICAgIXNuYXBzaG90LmRpZEFueUZpbGVDaGFuZ2VTaW5jZVN0YXJ0O1xuICAgIHJldHVybiAoXG4gICAgICBzaG91bGRWYWxpZGF0ZU9uQ29sZFN0YXJ0IHx8XG4gICAgICBzbmFwc2hvdC5kaWRBbnlUeXBlU2NyaXB0RmlsZUNoYW5nZVNpbmNlTGFzdFNuYXBzaG90XG4gICAgKTtcbiAgfTtcblxuICBwcml2YXRlIGRlcGxveSA9IGFzeW5jIChvcHRpb25zOiBTYW5kYm94T3B0aW9ucykgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkZXBsb3lSZXN1bHQgPSBhd2FpdCB0aGlzLmV4ZWN1dG9yLmRlcGxveShcbiAgICAgICAgYXdhaXQgdGhpcy5iYWNrZW5kSWRTYW5kYm94UmVzb2x2ZXIob3B0aW9ucy5pZGVudGlmaWVyKSxcbiAgICAgICAgLy8gSXQncyBpbXBvcnRhbnQgdG8gcGFzcyB0aGlzIGFzIGNhbGxiYWNrIHNvIHRoYXQgZGVib3VuY2UgZG9lc1xuICAgICAgICAvLyBub3QgcmVzZXQgdHJhY2tlciBwcmVtYXR1cmVseVxuICAgICAgICB0aGlzLnNob3VsZFZhbGlkYXRlQXBwU291cmNlc1xuICAgICAgKTtcbiAgICAgIHRoaXMucHJpbnRlci5sb2coJ1tTYW5kYm94XSBEZXBsb3ltZW50IHN1Y2Nlc3NmdWwnLCBMb2dMZXZlbC5ERUJVRyk7XG4gICAgICB0aGlzLmVtaXQoJ3N1Y2Nlc3NmdWxEZXBsb3ltZW50JywgZGVwbG95UmVzdWx0KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gUHJpbnQgYSBtZWFuaW5nZnVsIG1lc3NhZ2VcbiAgICAgIHRoaXMucHJpbnRlci5wcmludChmb3JtYXQuZXJyb3IodGhpcy5nZXRFcnJvck1lc3NhZ2UoZXJyb3IpKSk7XG4gICAgICB0aGlzLmVtaXQoJ2ZhaWxlZERlcGxveW1lbnQnLCBlcnJvcik7XG5cbiAgICAgIC8vIElmIHRoZSBlcnJvciBpcyBiZWNhdXNlIG9mIGEgbm9uLWFsbG93ZWQgZGVzdHJ1Y3RpdmUgY2hhbmdlIHN1Y2ggYXNcbiAgICAgIC8vIGh0dHBzOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9BV1NDbG91ZEZvcm1hdGlvbi9sYXRlc3QvVXNlckd1aWRlL2F3cy1yZXNvdXJjZS1jb2duaXRvLXVzZXJwb29sLmh0bWwjY2ZuLWNvZ25pdG8tdXNlcnBvb2wtYWxpYXNhdHRyaWJ1dGVzXG4gICAgICAvLyBvZmZlciB0byByZWNyZWF0ZSB0aGUgc2FuZGJveCBvciByZXZlcnQgdGhlIGNoYW5nZVxuICAgICAgaWYgKFxuICAgICAgICBlcnJvciBpbnN0YW5jZW9mIEFtcGxpZnlFcnJvciAmJlxuICAgICAgICBlcnJvci5uYW1lID09PSAnQ0ZOVXBkYXRlTm90U3VwcG9ydGVkRXJyb3InXG4gICAgICApIHtcbiAgICAgICAgYXdhaXQgdGhpcy5oYW5kbGVVbnN1cHBvcnRlZERlc3RydWN0aXZlQ2hhbmdlcyhvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIC8vIGVsc2UgZG8gbm90IHByb3BhZ2F0ZSBhbmQgbGV0IHRoZSBzYW5kYm94IGNvbnRpbnVlIHRvIHJ1blxuICAgIH1cbiAgfTtcblxuICBwcml2YXRlIHJlc2V0ID0gYXN5bmMgKG9wdGlvbnM6IFNhbmRib3hPcHRpb25zKSA9PiB7XG4gICAgYXdhaXQgdGhpcy5kZWxldGUoeyBpZGVudGlmaWVyOiBvcHRpb25zLmlkZW50aWZpZXIgfSk7XG4gICAgYXdhaXQgdGhpcy5zdGFydChvcHRpb25zKTtcbiAgfTtcblxuICAvKipcbiAgICogSnVzdCBhIHNob3J0aGFuZCBjb25zb2xlIGxvZyB0byBpbmRpY2F0ZSB3aGVuZXZlciB3YXRjaGVyIGlzIGdvaW5nIGlkbGVcbiAgICovXG4gIHByaXZhdGUgZW1pdFdhdGNoaW5nID0gKCkgPT4ge1xuICAgIHRoaXMucHJpbnRlci5sb2coYFtTYW5kYm94XSBXYXRjaGluZyBmb3IgZmlsZSBjaGFuZ2VzLi4uYCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlYWRzIGFuZCBwYXJzZXMgLmdpdGlnbm9yZSBmaWxlIGFuZCByZXR1cm5zIHRoZSBsaXN0IG9mIHBhdGhzXG4gICAqL1xuICBwcml2YXRlIGdldEdpdElnbm9yZWRQYXRocyA9ICgpID0+IHtcbiAgICBjb25zdCBnaXRJZ25vcmVGaWxlUGF0aCA9IHBhdGguam9pbihwcm9jZXNzLmN3ZCgpLCAnLmdpdGlnbm9yZScpO1xuICAgIGlmIChmcy5leGlzdHNTeW5jKGdpdElnbm9yZUZpbGVQYXRoKSkge1xuICAgICAgcmV0dXJuIHBhcnNlR2l0SWdub3JlXG4gICAgICAgIC5wYXJzZShnaXRJZ25vcmVGaWxlUGF0aClcbiAgICAgICAgLnBhdHRlcm5zLm1hcCgocGF0dGVybjogc3RyaW5nKSA9PlxuICAgICAgICAgIHBhdHRlcm4uc3RhcnRzV2l0aCgnLycpID8gcGF0dGVybi5zdWJzdHJpbmcoMSkgOiBwYXR0ZXJuXG4gICAgICAgIClcbiAgICAgICAgLmZpbHRlcigocGF0dGVybjogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgaWYgKHBhdHRlcm4uc3RhcnRzV2l0aCgnIScpKSB7XG4gICAgICAgICAgICB0aGlzLnByaW50ZXIubG9nKFxuICAgICAgICAgICAgICBgW1NhbmRib3hdIFBhdHRlcm4gJHtwYXR0ZXJufSBmb3VuZCBpbiAuZ2l0aWdub3JlLiBcIiR7cGF0dGVybi5zdWJzdHJpbmcoXG4gICAgICAgICAgICAgICAgMVxuICAgICAgICAgICAgICApfVwiIHdpbGwgbm90IGJlIHdhdGNoZWQgaWYgb3RoZXIgcGF0dGVybnMgaW4gLmdpdGlnbm9yZSBhcmUgZXhjbHVkaW5nIGl0LmBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYSBnaXZlbiByZWdpb24gaGFzIGJlZW4gYm9vdHN0cmFwcGVkIHdpdGggPj0gbWluIHZlcnNpb24gdXNpbmcgQ0ZOIGRlc2NyaWJlU3RhY2tzIHdpdGggQ0RLVG9vbEtpdC5cbiAgICogQHJldHVybnMgQSBCb29sZWFuIHRoYXQgcmVwcmVzZW50cyBpZiByZWdpb24gaGFzIGJlZW4gYm9vdHN0cmFwcGVkLlxuICAgKi9cbiAgcHJpdmF0ZSBpc0Jvb3RzdHJhcHBlZCA9IGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBTdGFja3M6IHN0YWNrcyB9ID0gYXdhaXQgdGhpcy5jZm5DbGllbnQuc2VuZChcbiAgICAgICAgbmV3IERlc2NyaWJlU3RhY2tzQ29tbWFuZCh7XG4gICAgICAgICAgU3RhY2tOYW1lOiBDREtfQk9PVFNUUkFQX1NUQUNLX05BTUUsXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgICAgY29uc3QgYm9vdHN0cmFwVmVyc2lvbiA9IHN0YWNrcz8uWzBdPy5PdXRwdXRzPy5maW5kKFxuICAgICAgICAob3V0cHV0KSA9PiBvdXRwdXQuT3V0cHV0S2V5ID09PSBDREtfQk9PVFNUUkFQX1ZFUlNJT05fS0VZXG4gICAgICApPy5PdXRwdXRWYWx1ZTtcbiAgICAgIGlmIChcbiAgICAgICAgIWJvb3RzdHJhcFZlcnNpb24gfHxcbiAgICAgICAgTnVtYmVyKGJvb3RzdHJhcFZlcnNpb24pIDwgQ0RLX01JTl9CT09UU1RSQVBfVkVSU0lPTlxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChcbiAgICAgICAgZSAmJlxuICAgICAgICB0eXBlb2YgZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgJ21lc3NhZ2UnIGluIGUgJiZcbiAgICAgICAgdHlwZW9mIGUubWVzc2FnZSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgZS5tZXNzYWdlLmluY2x1ZGVzKCdkb2VzIG5vdCBleGlzdCcpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gSWYgd2UgYXJlIHVuYWJsZSB0byBnZXQgdGhlIHN0YWNrIGluZm8gZHVlIHRvIG90aGVyIHJlYXNvbnMoQWNjZXNzRGVuaWVkKSwgd2UgZmFpbCBmYXN0LlxuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIHByaW50YWJsZSBlcnJvciBtZXNzYWdlIGZyb20gdGhlIHRocm93biBlcnJvclxuICAgKi9cbiAgcHJpdmF0ZSBnZXRFcnJvck1lc3NhZ2UgPSAoZXJyb3I6IHVua25vd24pID0+IHtcbiAgICBsZXQgbWVzc2FnZTtcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgbWVzc2FnZSA9IGVycm9yLm1lc3NhZ2U7XG5cbiAgICAgIC8vIEFkZCB0aGUgZG93bnN0cmVhbSBleGNlcHRpb25cbiAgICAgIGlmIChlcnJvci5jYXVzZSAmJiBlcnJvci5jYXVzZSBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLmNhdXNlLm1lc3NhZ2UpIHtcbiAgICAgICAgbWVzc2FnZSA9IGAke21lc3NhZ2V9XFxuQ2F1c2VkIEJ5OiAke2Vycm9yLmNhdXNlLm1lc3NhZ2V9XFxuYDtcbiAgICAgIH1cblxuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgQW1wbGlmeUVycm9yICYmIGVycm9yLnJlc29sdXRpb24pIHtcbiAgICAgICAgbWVzc2FnZSA9IGAke21lc3NhZ2V9XFxuUmVzb2x1dGlvbjogJHtlcnJvci5yZXNvbHV0aW9ufVxcbmA7XG4gICAgICB9XG4gICAgfSBlbHNlIG1lc3NhZ2UgPSBTdHJpbmcoZXJyb3IpO1xuICAgIHJldHVybiBtZXNzYWdlO1xuICB9O1xuXG4gIHByaXZhdGUgaGFuZGxlVW5zdXBwb3J0ZWREZXN0cnVjdGl2ZUNoYW5nZXMgPSBhc3luYyAoXG4gICAgb3B0aW9uczogU2FuZGJveE9wdGlvbnNcbiAgKSA9PiB7XG4gICAgdGhpcy5wcmludGVyLnByaW50KFxuICAgICAgZm9ybWF0LmVycm9yKFxuICAgICAgICAnW1NhbmRib3hdIFdlIGNhbm5vdCBkZXBsb3kgeW91ciBuZXcgY2hhbmdlcy4gWW91IGNhbiBlaXRoZXIgcmV2ZXJ0IHRoZW0gb3IgcmVjcmVhdGUgeW91ciBzYW5kYm94IHdpdGggdGhlIG5ldyBjaGFuZ2VzIChkZWxldGluZyBhbGwgdXNlciBkYXRhKSdcbiAgICAgIClcbiAgICApO1xuICAgIC8vIG9mZmVyIHRvIHJlY3JlYXRlIHRoZSBzYW5kYm94IHdpdGggbmV3IHByb3BlcnRpZXNcbiAgICBjb25zdCBhbnN3ZXIgPSBhd2FpdCBBbXBsaWZ5UHJvbXB0ZXIueWVzT3JObyh7XG4gICAgICBtZXNzYWdlOlxuICAgICAgICAnV291bGQgeW91IGxpa2UgdG8gcmVjcmVhdGUgeW91ciBzYW5kYm94IChkZWxldGluZyBhbGwgdXNlciBkYXRhKT8nLFxuICAgICAgZGVmYXVsdFZhbHVlOiBmYWxzZSxcbiAgICB9KTtcbiAgICBpZiAoYW5zd2VyKSB7XG4gICAgICBhd2FpdCB0aGlzLnN0b3AoKTtcbiAgICAgIGF3YWl0IHRoaXMucmVzZXQob3B0aW9ucyk7XG4gICAgfVxuICAgIC8vIGVsc2UgbGV0IHRoZSBzYW5kYm94IGNvbnRpbnVlIHNvIGN1c3RvbWVycyBjYW4gcmV2ZXJ0IHRoZWlyIGNoYW5nZXNcbiAgfTtcblxuICBwcml2YXRlIHByaW50U2FuZGJveE5hbWVJbmZvID0gYXN5bmMgKHNhbmRib3hJZGVudGlmaWVyPzogc3RyaW5nKSA9PiB7XG4gICAgY29uc3Qgc2FuZGJveEJhY2tlbmRJZCA9IGF3YWl0IHRoaXMuYmFja2VuZElkU2FuZGJveFJlc29sdmVyKFxuICAgICAgc2FuZGJveElkZW50aWZpZXJcbiAgICApO1xuICAgIGNvbnN0IHN0YWNrTmFtZSA9XG4gICAgICBCYWNrZW5kSWRlbnRpZmllckNvbnZlcnNpb25zLnRvU3RhY2tOYW1lKHNhbmRib3hCYWNrZW5kSWQpO1xuICAgIHRoaXMucHJpbnRlci5sb2coXG4gICAgICBmb3JtYXQuaW5kZW50KGZvcm1hdC5oaWdobGlnaHQoZm9ybWF0LmJvbGQoJ1xcbkFtcGxpZnkgU2FuZGJveFxcbicpKSlcbiAgICApO1xuICAgIHRoaXMucHJpbnRlci5sb2coXG4gICAgICBmb3JtYXQuaW5kZW50KGAke2Zvcm1hdC5ib2xkKCdJZGVudGlmaWVyOicpfSBcXHQke3NhbmRib3hCYWNrZW5kSWQubmFtZX1gKVxuICAgICk7XG4gICAgdGhpcy5wcmludGVyLmxvZyhmb3JtYXQuaW5kZW50KGAke2Zvcm1hdC5ib2xkKCdTdGFjazonKX0gXFx0JHtzdGFja05hbWV9YCkpO1xuICAgIGlmICghc2FuZGJveElkZW50aWZpZXIpIHtcbiAgICAgIHRoaXMucHJpbnRlci5sb2coXG4gICAgICAgIGAke2Zvcm1hdC5pbmRlbnQoXG4gICAgICAgICAgZm9ybWF0LmRpbSgnXFxuVG8gc3BlY2lmeSBhIGRpZmZlcmVudCBzYW5kYm94IGlkZW50aWZpZXIsIHVzZSAnKVxuICAgICAgICApfSR7Zm9ybWF0LmJvbGQoJy0taWRlbnRpZmllcicpfWBcbiAgICAgICk7XG4gICAgfVxuICB9O1xufVxuIl19